{"ast":null,"code":"/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed } from './_effect-chunk.mjs';\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn };","map":{"version":3,"names":["SIGNAL","runPostProducerCreatedFn","producerUpdateValueVersion","signalSetFn","producerMarkClean","signalUpdateFn","REACTIVE_NODE","UNSET","defaultEquals","COMPUTING","consumerBeforeComputation","ERRORED","consumerAfterComputation","producerAccessed","createLinkedSignal","sourceFn","computationFn","equalityFn","node","Object","create","LINKED_SIGNAL_NODE","source","computation","undefined","equal","linkedSignalGetter","value","error","getter","ngDevMode","debugName","toString","linkedSignalSetFn","newValue","linkedSignalUpdateFn","updater","dirty","kind","producerMustRecompute","producerRecomputeValue","Error","oldValue","prevConsumer","newSourceValue","prev","sourceValue","err","version"],"sources":["/Users/ariez/Downloads/crud/node_modules/@angular/core/fesm2022/_linked_signal-chunk.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed } from './_effect-chunk.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}