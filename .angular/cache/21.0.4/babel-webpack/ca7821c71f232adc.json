{"ast":null,"code":"/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nlet epoch = 1;\nlet postProducerCreatedFn = null;\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const prevProducerLink = activeConsumer.producersTail;\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n  let nextProducerLink = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n  const prevConsumerLink = node.consumersTail;\n  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n    return;\n  }\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\nfunction producerIncrementEpoch() {\n  epoch++;\n}\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    producerMarkClean(node);\n    return;\n  }\n  node.producerRecomputeValue(node);\n  producerMarkClean(node);\n}\nfunction producerNotifyConsumers(node) {\n  if (node.consumers === undefined) {\n    return;\n  }\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\nfunction consumerBeforeComputation(node) {\n  if (node) resetConsumerBeforeComputation(node);\n  return setActiveConsumer(node);\n}\nfunction resetConsumerBeforeComputation(node) {\n  node.producersTail = undefined;\n  node.recomputing = true;\n}\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (node) finalizeConsumerAfterComputation(node);\n}\nfunction finalizeConsumerAfterComputation(node) {\n  node.recomputing = false;\n  const producersTail = node.producersTail;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\nfunction consumerPollProducersForChange(node) {\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    producerUpdateValueVersion(producer);\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction consumerDestroy(node) {\n  if (consumerIsLive(node)) {\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\nfunction producerAddLiveConsumer(node, link) {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n  postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\nfunction isValidLink(checkLink, consumer) {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer;\n    } while (link !== undefined);\n  }\n  return false;\n}\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\nfunction createComputed(computation, equal) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const computed = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return computed;\n}\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        setActiveConsumer(null);\n        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\nlet postSignalSetFn = null;\nfunction createSignal(initialValue, equal) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = () => signalGetFn(node);\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  const set = newValue => signalSetFn(node, newValue);\n  const update = updateFn => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\nfunction signalGetFn(node) {\n  producerAccessed(node);\n  return node.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n  postSignalSetFn?.(node);\n}\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal'\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nconst BASE_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  dirty: true,\n  kind: 'effect'\n}))();\nfunction runEffect(node) {\n  node.dirty = false;\n  if (node.version > 0 && !consumerPollProducersForChange(node)) {\n    return;\n  }\n  node.version++;\n  const prevNode = consumerBeforeComputation(node);\n  try {\n    node.cleanup();\n    node.fn();\n  } finally {\n    consumerAfterComputation(node, prevNode);\n  }\n}\nexport { BASE_EFFECT_NODE, COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, finalizeConsumerAfterComputation, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, resetConsumerBeforeComputation, runEffect, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn, untracked };","map":{"version":3,"names":["activeConsumer","inNotificationPhase","epoch","postProducerCreatedFn","SIGNAL","Symbol","setActiveConsumer","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","version","lastCleanEpoch","dirty","producers","producersTail","consumers","consumersTail","recomputing","consumerAllowSignalWrites","consumerIsAlwaysLive","kind","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","Error","ngDevMode","prevProducerLink","producer","nextProducerLink","isRecomputing","nextProducer","lastReadVersion","prevConsumerLink","isValidLink","isLive","consumerIsLive","newLink","prevConsumer","nextConsumer","producerAddLiveConsumer","producerIncrementEpoch","producerUpdateValueVersion","consumerPollProducersForChange","producerMarkClean","producerNotifyConsumers","link","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","resetConsumerBeforeComputation","consumerAfterComputation","finalizeConsumerAfterComputation","toRemove","producerRemoveLiveConsumerLink","seenVersion","consumerDestroy","wasLive","producerLink","runPostProducerCreatedFn","setPostProducerCreatedFn","fn","checkLink","defaultEquals","a","b","Object","is","createComputed","computation","equal","create","COMPUTED_NODE","computed","ERRORED","error","debugName","toString","UNSET","COMPUTING","oldValue","newValue","wasEqual","err","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","getter","signalGetFn","set","signalSetFn","update","updateFn","signalUpdateFn","setPostSignalSetFn","signalValueChanged","updater","runPostSignalSetFn","untracked","nonReactiveReadsFn","BASE_EFFECT_NODE","runEffect","prevNode","cleanup"],"sources":["/Users/ariez/Downloads/crud/node_modules/@angular/core/fesm2022/_effect-chunk.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nlet epoch = 1;\nlet postProducerCreatedFn = null;\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const prevProducerLink = activeConsumer.producersTail;\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n  let nextProducerLink = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n  const prevConsumerLink = node.consumersTail;\n  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n    return;\n  }\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\nfunction producerIncrementEpoch() {\n  epoch++;\n}\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    producerMarkClean(node);\n    return;\n  }\n  node.producerRecomputeValue(node);\n  producerMarkClean(node);\n}\nfunction producerNotifyConsumers(node) {\n  if (node.consumers === undefined) {\n    return;\n  }\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\nfunction consumerBeforeComputation(node) {\n  if (node) resetConsumerBeforeComputation(node);\n  return setActiveConsumer(node);\n}\nfunction resetConsumerBeforeComputation(node) {\n  node.producersTail = undefined;\n  node.recomputing = true;\n}\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (node) finalizeConsumerAfterComputation(node);\n}\nfunction finalizeConsumerAfterComputation(node) {\n  node.recomputing = false;\n  const producersTail = node.producersTail;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\nfunction consumerPollProducersForChange(node) {\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    producerUpdateValueVersion(producer);\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction consumerDestroy(node) {\n  if (consumerIsLive(node)) {\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\nfunction producerAddLiveConsumer(node, link) {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n  postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\nfunction isValidLink(checkLink, consumer) {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer;\n    } while (link !== undefined);\n  }\n  return false;\n}\n\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n\nfunction createComputed(computation, equal) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const computed = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return computed;\n}\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        setActiveConsumer(null);\n        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\nlet postSignalSetFn = null;\nfunction createSignal(initialValue, equal) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = () => signalGetFn(node);\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  const set = newValue => signalSetFn(node, newValue);\n  const update = updateFn => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\nfunction signalGetFn(node) {\n  producerAccessed(node);\n  return node.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n  postSignalSetFn?.(node);\n}\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal'\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\n\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n\nconst BASE_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  dirty: true,\n  kind: 'effect'\n}))();\nfunction runEffect(node) {\n  node.dirty = false;\n  if (node.version > 0 && !consumerPollProducersForChange(node)) {\n    return;\n  }\n  node.version++;\n  const prevNode = consumerBeforeComputation(node);\n  try {\n    node.cleanup();\n    node.fn();\n  } finally {\n    consumerAfterComputation(node, prevNode);\n  }\n}\n\nexport { BASE_EFFECT_NODE, COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, finalizeConsumerAfterComputation, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, resetConsumerBeforeComputation, runEffect, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn, untracked };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,cAAc,GAAG,IAAI;AACzB,IAAIC,mBAAmB,GAAG,KAAK;AAC/B,IAAIC,KAAK,GAAG,CAAC;AACb,IAAIC,qBAAqB,GAAG,IAAI;AAChC,MAAMC,MAAM,GAAG,eAAeC,MAAM,CAAC,QAAQ,CAAC;AAC9C,SAASC,iBAAiBA,CAACC,QAAQ,EAAE;EACnC,MAAMC,IAAI,GAAGR,cAAc;EAC3BA,cAAc,GAAGO,QAAQ;EACzB,OAAOC,IAAI;AACb;AACA,SAASC,iBAAiBA,CAAA,EAAG;EAC3B,OAAOT,cAAc;AACvB;AACA,SAASU,qBAAqBA,CAAA,EAAG;EAC/B,OAAOT,mBAAmB;AAC5B;AACA,SAASU,UAAUA,CAACC,KAAK,EAAE;EACzB,OAAOA,KAAK,CAACR,MAAM,CAAC,KAAKS,SAAS;AACpC;AACA,MAAMC,aAAa,GAAG;EACpBC,OAAO,EAAE,CAAC;EACVC,cAAc,EAAE,CAAC;EACjBC,KAAK,EAAE,KAAK;EACZC,SAAS,EAAEL,SAAS;EACpBM,aAAa,EAAEN,SAAS;EACxBO,SAAS,EAAEP,SAAS;EACpBQ,aAAa,EAAER,SAAS;EACxBS,WAAW,EAAE,KAAK;EAClBC,yBAAyB,EAAE,KAAK;EAChCC,oBAAoB,EAAE,KAAK;EAC3BC,IAAI,EAAE,SAAS;EACfC,qBAAqB,EAAEA,CAAA,KAAM,KAAK;EAClCC,sBAAsB,EAAEA,CAAA,KAAM,CAAC,CAAC;EAChCC,mBAAmB,EAAEA,CAAA,KAAM,CAAC,CAAC;EAC7BC,oBAAoB,EAAEA,CAAA,KAAM,CAAC;AAC/B,CAAC;AACD,SAASC,gBAAgBA,CAACC,IAAI,EAAE;EAC9B,IAAI9B,mBAAmB,EAAE;IACvB,MAAM,IAAI+B,KAAK,CAAC,OAAOC,SAAS,KAAK,WAAW,IAAIA,SAAS,GAAG,wDAAwD,GAAG,EAAE,CAAC;EAChI;EACA,IAAIjC,cAAc,KAAK,IAAI,EAAE;IAC3B;EACF;EACAA,cAAc,CAAC6B,oBAAoB,CAACE,IAAI,CAAC;EACzC,MAAMG,gBAAgB,GAAGlC,cAAc,CAACmB,aAAa;EACrD,IAAIe,gBAAgB,KAAKrB,SAAS,IAAIqB,gBAAgB,CAACC,QAAQ,KAAKJ,IAAI,EAAE;IACxE;EACF;EACA,IAAIK,gBAAgB,GAAGvB,SAAS;EAChC,MAAMwB,aAAa,GAAGrC,cAAc,CAACsB,WAAW;EAChD,IAAIe,aAAa,EAAE;IACjBD,gBAAgB,GAAGF,gBAAgB,KAAKrB,SAAS,GAAGqB,gBAAgB,CAACI,YAAY,GAAGtC,cAAc,CAACkB,SAAS;IAC5G,IAAIkB,gBAAgB,KAAKvB,SAAS,IAAIuB,gBAAgB,CAACD,QAAQ,KAAKJ,IAAI,EAAE;MACxE/B,cAAc,CAACmB,aAAa,GAAGiB,gBAAgB;MAC/CA,gBAAgB,CAACG,eAAe,GAAGR,IAAI,CAAChB,OAAO;MAC/C;IACF;EACF;EACA,MAAMyB,gBAAgB,GAAGT,IAAI,CAACV,aAAa;EAC3C,IAAImB,gBAAgB,KAAK3B,SAAS,IAAI2B,gBAAgB,CAACjC,QAAQ,KAAKP,cAAc,KAAK,CAACqC,aAAa,IAAII,WAAW,CAACD,gBAAgB,EAAExC,cAAc,CAAC,CAAC,EAAE;IACvJ;EACF;EACA,MAAM0C,MAAM,GAAGC,cAAc,CAAC3C,cAAc,CAAC;EAC7C,MAAM4C,OAAO,GAAG;IACdT,QAAQ,EAAEJ,IAAI;IACdxB,QAAQ,EAAEP,cAAc;IACxBsC,YAAY,EAAEF,gBAAgB;IAC9BS,YAAY,EAAEL,gBAAgB;IAC9BD,eAAe,EAAER,IAAI,CAAChB,OAAO;IAC7B+B,YAAY,EAAEjC;EAChB,CAAC;EACDb,cAAc,CAACmB,aAAa,GAAGyB,OAAO;EACtC,IAAIV,gBAAgB,KAAKrB,SAAS,EAAE;IAClCqB,gBAAgB,CAACI,YAAY,GAAGM,OAAO;EACzC,CAAC,MAAM;IACL5C,cAAc,CAACkB,SAAS,GAAG0B,OAAO;EACpC;EACA,IAAIF,MAAM,EAAE;IACVK,uBAAuB,CAAChB,IAAI,EAAEa,OAAO,CAAC;EACxC;AACF;AACA,SAASI,sBAAsBA,CAAA,EAAG;EAChC9C,KAAK,EAAE;AACT;AACA,SAAS+C,0BAA0BA,CAAClB,IAAI,EAAE;EACxC,IAAIY,cAAc,CAACZ,IAAI,CAAC,IAAI,CAACA,IAAI,CAACd,KAAK,EAAE;IACvC;EACF;EACA,IAAI,CAACc,IAAI,CAACd,KAAK,IAAIc,IAAI,CAACf,cAAc,KAAKd,KAAK,EAAE;IAChD;EACF;EACA,IAAI,CAAC6B,IAAI,CAACL,qBAAqB,CAACK,IAAI,CAAC,IAAI,CAACmB,8BAA8B,CAACnB,IAAI,CAAC,EAAE;IAC9EoB,iBAAiB,CAACpB,IAAI,CAAC;IACvB;EACF;EACAA,IAAI,CAACJ,sBAAsB,CAACI,IAAI,CAAC;EACjCoB,iBAAiB,CAACpB,IAAI,CAAC;AACzB;AACA,SAASqB,uBAAuBA,CAACrB,IAAI,EAAE;EACrC,IAAIA,IAAI,CAACX,SAAS,KAAKP,SAAS,EAAE;IAChC;EACF;EACA,MAAML,IAAI,GAAGP,mBAAmB;EAChCA,mBAAmB,GAAG,IAAI;EAC1B,IAAI;IACF,KAAK,IAAIoD,IAAI,GAAGtB,IAAI,CAACX,SAAS,EAAEiC,IAAI,KAAKxC,SAAS,EAAEwC,IAAI,GAAGA,IAAI,CAACP,YAAY,EAAE;MAC5E,MAAMvC,QAAQ,GAAG8C,IAAI,CAAC9C,QAAQ;MAC9B,IAAI,CAACA,QAAQ,CAACU,KAAK,EAAE;QACnBqC,iBAAiB,CAAC/C,QAAQ,CAAC;MAC7B;IACF;EACF,CAAC,SAAS;IACRN,mBAAmB,GAAGO,IAAI;EAC5B;AACF;AACA,SAAS+C,sBAAsBA,CAAA,EAAG;EAChC,OAAOvD,cAAc,EAAEuB,yBAAyB,KAAK,KAAK;AAC5D;AACA,SAAS+B,iBAAiBA,CAACvB,IAAI,EAAE;EAC/BA,IAAI,CAACd,KAAK,GAAG,IAAI;EACjBmC,uBAAuB,CAACrB,IAAI,CAAC;EAC7BA,IAAI,CAACH,mBAAmB,GAAGG,IAAI,CAAC;AAClC;AACA,SAASoB,iBAAiBA,CAACpB,IAAI,EAAE;EAC/BA,IAAI,CAACd,KAAK,GAAG,KAAK;EAClBc,IAAI,CAACf,cAAc,GAAGd,KAAK;AAC7B;AACA,SAASsD,yBAAyBA,CAACzB,IAAI,EAAE;EACvC,IAAIA,IAAI,EAAE0B,8BAA8B,CAAC1B,IAAI,CAAC;EAC9C,OAAOzB,iBAAiB,CAACyB,IAAI,CAAC;AAChC;AACA,SAAS0B,8BAA8BA,CAAC1B,IAAI,EAAE;EAC5CA,IAAI,CAACZ,aAAa,GAAGN,SAAS;EAC9BkB,IAAI,CAACT,WAAW,GAAG,IAAI;AACzB;AACA,SAASoC,wBAAwBA,CAAC3B,IAAI,EAAEc,YAAY,EAAE;EACpDvC,iBAAiB,CAACuC,YAAY,CAAC;EAC/B,IAAId,IAAI,EAAE4B,gCAAgC,CAAC5B,IAAI,CAAC;AAClD;AACA,SAAS4B,gCAAgCA,CAAC5B,IAAI,EAAE;EAC9CA,IAAI,CAACT,WAAW,GAAG,KAAK;EACxB,MAAMH,aAAa,GAAGY,IAAI,CAACZ,aAAa;EACxC,IAAIyC,QAAQ,GAAGzC,aAAa,KAAKN,SAAS,GAAGM,aAAa,CAACmB,YAAY,GAAGP,IAAI,CAACb,SAAS;EACxF,IAAI0C,QAAQ,KAAK/C,SAAS,EAAE;IAC1B,IAAI8B,cAAc,CAACZ,IAAI,CAAC,EAAE;MACxB,GAAG;QACD6B,QAAQ,GAAGC,8BAA8B,CAACD,QAAQ,CAAC;MACrD,CAAC,QAAQA,QAAQ,KAAK/C,SAAS;IACjC;IACA,IAAIM,aAAa,KAAKN,SAAS,EAAE;MAC/BM,aAAa,CAACmB,YAAY,GAAGzB,SAAS;IACxC,CAAC,MAAM;MACLkB,IAAI,CAACb,SAAS,GAAGL,SAAS;IAC5B;EACF;AACF;AACA,SAASqC,8BAA8BA,CAACnB,IAAI,EAAE;EAC5C,KAAK,IAAIsB,IAAI,GAAGtB,IAAI,CAACb,SAAS,EAAEmC,IAAI,KAAKxC,SAAS,EAAEwC,IAAI,GAAGA,IAAI,CAACf,YAAY,EAAE;IAC5E,MAAMH,QAAQ,GAAGkB,IAAI,CAAClB,QAAQ;IAC9B,MAAM2B,WAAW,GAAGT,IAAI,CAACd,eAAe;IACxC,IAAIuB,WAAW,KAAK3B,QAAQ,CAACpB,OAAO,EAAE;MACpC,OAAO,IAAI;IACb;IACAkC,0BAA0B,CAACd,QAAQ,CAAC;IACpC,IAAI2B,WAAW,KAAK3B,QAAQ,CAACpB,OAAO,EAAE;MACpC,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AACA,SAASgD,eAAeA,CAAChC,IAAI,EAAE;EAC7B,IAAIY,cAAc,CAACZ,IAAI,CAAC,EAAE;IACxB,IAAIsB,IAAI,GAAGtB,IAAI,CAACb,SAAS;IACzB,OAAOmC,IAAI,KAAKxC,SAAS,EAAE;MACzBwC,IAAI,GAAGQ,8BAA8B,CAACR,IAAI,CAAC;IAC7C;EACF;EACAtB,IAAI,CAACb,SAAS,GAAGL,SAAS;EAC1BkB,IAAI,CAACZ,aAAa,GAAGN,SAAS;EAC9BkB,IAAI,CAACX,SAAS,GAAGP,SAAS;EAC1BkB,IAAI,CAACV,aAAa,GAAGR,SAAS;AAChC;AACA,SAASkC,uBAAuBA,CAAChB,IAAI,EAAEsB,IAAI,EAAE;EAC3C,MAAMhC,aAAa,GAAGU,IAAI,CAACV,aAAa;EACxC,MAAM2C,OAAO,GAAGrB,cAAc,CAACZ,IAAI,CAAC;EACpC,IAAIV,aAAa,KAAKR,SAAS,EAAE;IAC/BwC,IAAI,CAACP,YAAY,GAAGzB,aAAa,CAACyB,YAAY;IAC9CzB,aAAa,CAACyB,YAAY,GAAGO,IAAI;EACnC,CAAC,MAAM;IACLA,IAAI,CAACP,YAAY,GAAGjC,SAAS;IAC7BkB,IAAI,CAACX,SAAS,GAAGiC,IAAI;EACvB;EACAA,IAAI,CAACR,YAAY,GAAGxB,aAAa;EACjCU,IAAI,CAACV,aAAa,GAAGgC,IAAI;EACzB,IAAI,CAACW,OAAO,EAAE;IACZ,KAAK,IAAIX,IAAI,GAAGtB,IAAI,CAACb,SAAS,EAAEmC,IAAI,KAAKxC,SAAS,EAAEwC,IAAI,GAAGA,IAAI,CAACf,YAAY,EAAE;MAC5ES,uBAAuB,CAACM,IAAI,CAAClB,QAAQ,EAAEkB,IAAI,CAAC;IAC9C;EACF;AACF;AACA,SAASQ,8BAA8BA,CAACR,IAAI,EAAE;EAC5C,MAAMlB,QAAQ,GAAGkB,IAAI,CAAClB,QAAQ;EAC9B,MAAMG,YAAY,GAAGe,IAAI,CAACf,YAAY;EACtC,MAAMQ,YAAY,GAAGO,IAAI,CAACP,YAAY;EACtC,MAAMD,YAAY,GAAGQ,IAAI,CAACR,YAAY;EACtCQ,IAAI,CAACP,YAAY,GAAGjC,SAAS;EAC7BwC,IAAI,CAACR,YAAY,GAAGhC,SAAS;EAC7B,IAAIiC,YAAY,KAAKjC,SAAS,EAAE;IAC9BiC,YAAY,CAACD,YAAY,GAAGA,YAAY;EAC1C,CAAC,MAAM;IACLV,QAAQ,CAACd,aAAa,GAAGwB,YAAY;EACvC;EACA,IAAIA,YAAY,KAAKhC,SAAS,EAAE;IAC9BgC,YAAY,CAACC,YAAY,GAAGA,YAAY;EAC1C,CAAC,MAAM;IACLX,QAAQ,CAACf,SAAS,GAAG0B,YAAY;IACjC,IAAI,CAACH,cAAc,CAACR,QAAQ,CAAC,EAAE;MAC7B,IAAI8B,YAAY,GAAG9B,QAAQ,CAACjB,SAAS;MACrC,OAAO+C,YAAY,KAAKpD,SAAS,EAAE;QACjCoD,YAAY,GAAGJ,8BAA8B,CAACI,YAAY,CAAC;MAC7D;IACF;EACF;EACA,OAAO3B,YAAY;AACrB;AACA,SAASK,cAAcA,CAACZ,IAAI,EAAE;EAC5B,OAAOA,IAAI,CAACP,oBAAoB,IAAIO,IAAI,CAACX,SAAS,KAAKP,SAAS;AAClE;AACA,SAASqD,wBAAwBA,CAACnC,IAAI,EAAE;EACtC5B,qBAAqB,GAAG4B,IAAI,CAAC;AAC/B;AACA,SAASoC,wBAAwBA,CAACC,EAAE,EAAE;EACpC,MAAM5D,IAAI,GAAGL,qBAAqB;EAClCA,qBAAqB,GAAGiE,EAAE;EAC1B,OAAO5D,IAAI;AACb;AACA,SAASiC,WAAWA,CAAC4B,SAAS,EAAE9D,QAAQ,EAAE;EACxC,MAAMY,aAAa,GAAGZ,QAAQ,CAACY,aAAa;EAC5C,IAAIA,aAAa,KAAKN,SAAS,EAAE;IAC/B,IAAIwC,IAAI,GAAG9C,QAAQ,CAACW,SAAS;IAC7B,GAAG;MACD,IAAImC,IAAI,KAAKgB,SAAS,EAAE;QACtB,OAAO,IAAI;MACb;MACA,IAAIhB,IAAI,KAAKlC,aAAa,EAAE;QAC1B;MACF;MACAkC,IAAI,GAAGA,IAAI,CAACf,YAAY;IAC1B,CAAC,QAAQe,IAAI,KAAKxC,SAAS;EAC7B;EACA,OAAO,KAAK;AACd;AAEA,SAASyD,aAAaA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC3B,OAAOC,MAAM,CAACC,EAAE,CAACH,CAAC,EAAEC,CAAC,CAAC;AACxB;AAEA,SAASG,cAAcA,CAACC,WAAW,EAAEC,KAAK,EAAE;EAC1C,MAAM9C,IAAI,GAAG0C,MAAM,CAACK,MAAM,CAACC,aAAa,CAAC;EACzChD,IAAI,CAAC6C,WAAW,GAAGA,WAAW;EAC9B,IAAIC,KAAK,KAAKhE,SAAS,EAAE;IACvBkB,IAAI,CAAC8C,KAAK,GAAGA,KAAK;EACpB;EACA,MAAMG,QAAQ,GAAGA,CAAA,KAAM;IACrB/B,0BAA0B,CAAClB,IAAI,CAAC;IAChCD,gBAAgB,CAACC,IAAI,CAAC;IACtB,IAAIA,IAAI,CAACnB,KAAK,KAAKqE,OAAO,EAAE;MAC1B,MAAMlD,IAAI,CAACmD,KAAK;IAClB;IACA,OAAOnD,IAAI,CAACnB,KAAK;EACnB,CAAC;EACDoE,QAAQ,CAAC5E,MAAM,CAAC,GAAG2B,IAAI;EACvB,IAAI,OAAOE,SAAS,KAAK,WAAW,IAAIA,SAAS,EAAE;IACjD,MAAMkD,SAAS,GAAGpD,IAAI,CAACoD,SAAS,GAAG,IAAI,GAAGpD,IAAI,CAACoD,SAAS,GAAG,GAAG,GAAG,EAAE;IACnEH,QAAQ,CAACI,QAAQ,GAAG,MAAM,YAAYD,SAAS,KAAKpD,IAAI,CAACnB,KAAK,GAAG;EACnE;EACAsD,wBAAwB,CAACnC,IAAI,CAAC;EAC9B,OAAOiD,QAAQ;AACjB;AACA,MAAMK,KAAK,GAAG,eAAehF,MAAM,CAAC,OAAO,CAAC;AAC5C,MAAMiF,SAAS,GAAG,eAAejF,MAAM,CAAC,WAAW,CAAC;AACpD,MAAM4E,OAAO,GAAG,eAAe5E,MAAM,CAAC,SAAS,CAAC;AAChD,MAAM0E,aAAa,GAAG,eAAe,CAAC,MAAM;EAC1C,OAAO;IACL,GAAGjE,aAAa;IAChBF,KAAK,EAAEyE,KAAK;IACZpE,KAAK,EAAE,IAAI;IACXiE,KAAK,EAAE,IAAI;IACXL,KAAK,EAAEP,aAAa;IACpB7C,IAAI,EAAE,UAAU;IAChBC,qBAAqBA,CAACK,IAAI,EAAE;MAC1B,OAAOA,IAAI,CAACnB,KAAK,KAAKyE,KAAK,IAAItD,IAAI,CAACnB,KAAK,KAAK0E,SAAS;IACzD,CAAC;IACD3D,sBAAsBA,CAACI,IAAI,EAAE;MAC3B,IAAIA,IAAI,CAACnB,KAAK,KAAK0E,SAAS,EAAE;QAC5B,MAAM,IAAItD,KAAK,CAAC,OAAOC,SAAS,KAAK,WAAW,IAAIA,SAAS,GAAG,iCAAiC,GAAG,EAAE,CAAC;MACzG;MACA,MAAMsD,QAAQ,GAAGxD,IAAI,CAACnB,KAAK;MAC3BmB,IAAI,CAACnB,KAAK,GAAG0E,SAAS;MACtB,MAAMzC,YAAY,GAAGW,yBAAyB,CAACzB,IAAI,CAAC;MACpD,IAAIyD,QAAQ;MACZ,IAAIC,QAAQ,GAAG,KAAK;MACpB,IAAI;QACFD,QAAQ,GAAGzD,IAAI,CAAC6C,WAAW,CAAC,CAAC;QAC7BtE,iBAAiB,CAAC,IAAI,CAAC;QACvBmF,QAAQ,GAAGF,QAAQ,KAAKF,KAAK,IAAIE,QAAQ,KAAKN,OAAO,IAAIO,QAAQ,KAAKP,OAAO,IAAIlD,IAAI,CAAC8C,KAAK,CAACU,QAAQ,EAAEC,QAAQ,CAAC;MACjH,CAAC,CAAC,OAAOE,GAAG,EAAE;QACZF,QAAQ,GAAGP,OAAO;QAClBlD,IAAI,CAACmD,KAAK,GAAGQ,GAAG;MAClB,CAAC,SAAS;QACRhC,wBAAwB,CAAC3B,IAAI,EAAEc,YAAY,CAAC;MAC9C;MACA,IAAI4C,QAAQ,EAAE;QACZ1D,IAAI,CAACnB,KAAK,GAAG2E,QAAQ;QACrB;MACF;MACAxD,IAAI,CAACnB,KAAK,GAAG4E,QAAQ;MACrBzD,IAAI,CAAChB,OAAO,EAAE;IAChB;EACF,CAAC;AACH,CAAC,EAAE,CAAC;AAEJ,SAAS4E,iBAAiBA,CAAA,EAAG;EAC3B,MAAM,IAAI3D,KAAK,CAAC,CAAC;AACnB;AACA,IAAI4D,gCAAgC,GAAGD,iBAAiB;AACxD,SAASE,8BAA8BA,CAAC9D,IAAI,EAAE;EAC5C6D,gCAAgC,CAAC7D,IAAI,CAAC;AACxC;AACA,SAAS+D,iCAAiCA,CAAC1B,EAAE,EAAE;EAC7CwB,gCAAgC,GAAGxB,EAAE;AACvC;AAEA,IAAI2B,eAAe,GAAG,IAAI;AAC1B,SAASC,YAAYA,CAACC,YAAY,EAAEpB,KAAK,EAAE;EACzC,MAAM9C,IAAI,GAAG0C,MAAM,CAACK,MAAM,CAACoB,WAAW,CAAC;EACvCnE,IAAI,CAACnB,KAAK,GAAGqF,YAAY;EACzB,IAAIpB,KAAK,KAAKhE,SAAS,EAAE;IACvBkB,IAAI,CAAC8C,KAAK,GAAGA,KAAK;EACpB;EACA,MAAMsB,MAAM,GAAGA,CAAA,KAAMC,WAAW,CAACrE,IAAI,CAAC;EACtCoE,MAAM,CAAC/F,MAAM,CAAC,GAAG2B,IAAI;EACrB,IAAI,OAAOE,SAAS,KAAK,WAAW,IAAIA,SAAS,EAAE;IACjD,MAAMkD,SAAS,GAAGpD,IAAI,CAACoD,SAAS,GAAG,IAAI,GAAGpD,IAAI,CAACoD,SAAS,GAAG,GAAG,GAAG,EAAE;IACnEgB,MAAM,CAACf,QAAQ,GAAG,MAAM,UAAUD,SAAS,KAAKpD,IAAI,CAACnB,KAAK,GAAG;EAC/D;EACAsD,wBAAwB,CAACnC,IAAI,CAAC;EAC9B,MAAMsE,GAAG,GAAGb,QAAQ,IAAIc,WAAW,CAACvE,IAAI,EAAEyD,QAAQ,CAAC;EACnD,MAAMe,MAAM,GAAGC,QAAQ,IAAIC,cAAc,CAAC1E,IAAI,EAAEyE,QAAQ,CAAC;EACzD,OAAO,CAACL,MAAM,EAAEE,GAAG,EAAEE,MAAM,CAAC;AAC9B;AACA,SAASG,kBAAkBA,CAACtC,EAAE,EAAE;EAC9B,MAAM5D,IAAI,GAAGuF,eAAe;EAC5BA,eAAe,GAAG3B,EAAE;EACpB,OAAO5D,IAAI;AACb;AACA,SAAS4F,WAAWA,CAACrE,IAAI,EAAE;EACzBD,gBAAgB,CAACC,IAAI,CAAC;EACtB,OAAOA,IAAI,CAACnB,KAAK;AACnB;AACA,SAAS0F,WAAWA,CAACvE,IAAI,EAAEyD,QAAQ,EAAE;EACnC,IAAI,CAACjC,sBAAsB,CAAC,CAAC,EAAE;IAC7BsC,8BAA8B,CAAC9D,IAAI,CAAC;EACtC;EACA,IAAI,CAACA,IAAI,CAAC8C,KAAK,CAAC9C,IAAI,CAACnB,KAAK,EAAE4E,QAAQ,CAAC,EAAE;IACrCzD,IAAI,CAACnB,KAAK,GAAG4E,QAAQ;IACrBmB,kBAAkB,CAAC5E,IAAI,CAAC;EAC1B;AACF;AACA,SAAS0E,cAAcA,CAAC1E,IAAI,EAAE6E,OAAO,EAAE;EACrC,IAAI,CAACrD,sBAAsB,CAAC,CAAC,EAAE;IAC7BsC,8BAA8B,CAAC9D,IAAI,CAAC;EACtC;EACAuE,WAAW,CAACvE,IAAI,EAAE6E,OAAO,CAAC7E,IAAI,CAACnB,KAAK,CAAC,CAAC;AACxC;AACA,SAASiG,kBAAkBA,CAAC9E,IAAI,EAAE;EAChCgE,eAAe,GAAGhE,IAAI,CAAC;AACzB;AACA,MAAMmE,WAAW,GAAG,eAAe,CAAC,MAAM;EACxC,OAAO;IACL,GAAGpF,aAAa;IAChB+D,KAAK,EAAEP,aAAa;IACpB1D,KAAK,EAAEC,SAAS;IAChBY,IAAI,EAAE;EACR,CAAC;AACH,CAAC,EAAE,CAAC;AACJ,SAASkF,kBAAkBA,CAAC5E,IAAI,EAAE;EAChCA,IAAI,CAAChB,OAAO,EAAE;EACdiC,sBAAsB,CAAC,CAAC;EACxBI,uBAAuB,CAACrB,IAAI,CAAC;EAC7BgE,eAAe,GAAGhE,IAAI,CAAC;AACzB;AAEA,SAAS+E,SAASA,CAACC,kBAAkB,EAAE;EACrC,MAAMlE,YAAY,GAAGvC,iBAAiB,CAAC,IAAI,CAAC;EAC5C,IAAI;IACF,OAAOyG,kBAAkB,CAAC,CAAC;EAC7B,CAAC,SAAS;IACRzG,iBAAiB,CAACuC,YAAY,CAAC;EACjC;AACF;AAEA,MAAMmE,gBAAgB,GAAG,eAAe,CAAC,OAAO;EAC9C,GAAGlG,aAAa;EAChBU,oBAAoB,EAAE,IAAI;EAC1BD,yBAAyB,EAAE,IAAI;EAC/BN,KAAK,EAAE,IAAI;EACXQ,IAAI,EAAE;AACR,CAAC,CAAC,EAAE,CAAC;AACL,SAASwF,SAASA,CAAClF,IAAI,EAAE;EACvBA,IAAI,CAACd,KAAK,GAAG,KAAK;EAClB,IAAIc,IAAI,CAAChB,OAAO,GAAG,CAAC,IAAI,CAACmC,8BAA8B,CAACnB,IAAI,CAAC,EAAE;IAC7D;EACF;EACAA,IAAI,CAAChB,OAAO,EAAE;EACd,MAAMmG,QAAQ,GAAG1D,yBAAyB,CAACzB,IAAI,CAAC;EAChD,IAAI;IACFA,IAAI,CAACoF,OAAO,CAAC,CAAC;IACdpF,IAAI,CAACqC,EAAE,CAAC,CAAC;EACX,CAAC,SAAS;IACRV,wBAAwB,CAAC3B,IAAI,EAAEmF,QAAQ,CAAC;EAC1C;AACF;AAEA,SAASF,gBAAgB,EAAE1B,SAAS,EAAEL,OAAO,EAAEnE,aAAa,EAAEV,MAAM,EAAE8F,WAAW,EAAEb,KAAK,EAAE3B,wBAAwB,EAAEF,yBAAyB,EAAEO,eAAe,EAAET,iBAAiB,EAAEJ,8BAA8B,EAAEyB,cAAc,EAAEqB,YAAY,EAAE1B,aAAa,EAAEX,gCAAgC,EAAElD,iBAAiB,EAAEC,qBAAqB,EAAEC,UAAU,EAAEmB,gBAAgB,EAAEkB,sBAAsB,EAAEG,iBAAiB,EAAEC,uBAAuB,EAAEH,0BAA0B,EAAEM,sBAAsB,EAAEE,8BAA8B,EAAEwD,SAAS,EAAE/C,wBAAwB,EAAE2C,kBAAkB,EAAEvG,iBAAiB,EAAE6D,wBAAwB,EAAEuC,kBAAkB,EAAEZ,iCAAiC,EAAEM,WAAW,EAAEE,WAAW,EAAEG,cAAc,EAAEK,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}