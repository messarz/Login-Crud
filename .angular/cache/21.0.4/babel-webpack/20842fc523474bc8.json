{"ast":null,"code":"/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { HttpHeaders, HttpParams, HttpRequest, HttpEventType, HttpErrorResponse, HttpClient, HTTP_ROOT_INTERCEPTOR_FNS, HttpResponse } from './_module-chunk.mjs';\nexport { FetchBackend, HTTP_INTERCEPTORS, HttpBackend, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration, HttpInterceptorHandler as ɵHttpInterceptingHandler, REQUESTS_CONTRIBUTE_TO_STABILITY as ɵREQUESTS_CONTRIBUTE_TO_STABILITY } from './_module-chunk.mjs';\nimport { assertInInjectionContext, inject, Injector, ɵResourceImpl as _ResourceImpl, linkedSignal, computed, signal, ɵencapsulateResourceError as _encapsulateResourceError, ɵRuntimeError as _RuntimeError, InjectionToken, ɵperformanceMarkFeature as _performanceMarkFeature, APP_BOOTSTRAP_LISTENER, ApplicationRef, TransferState, makeStateKey, ɵtruncateMiddle as _truncateMiddle, ɵformatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { of } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport './_xhr-chunk.mjs';\nimport './_platform_location-chunk.mjs';\nconst httpResource = /*#__PURE__*/(() => {\n  const jsonFn = makeHttpResourceFn('json');\n  jsonFn.arrayBuffer = makeHttpResourceFn('arraybuffer');\n  jsonFn.blob = makeHttpResourceFn('blob');\n  jsonFn.text = makeHttpResourceFn('text');\n  return jsonFn;\n})();\nfunction makeHttpResourceFn(responseType) {\n  return function httpResource(request, options) {\n    if (ngDevMode && !options?.injector) {\n      assertInInjectionContext(httpResource);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.debugName, options?.parse, options?.equal);\n  };\n}\nfunction normalizeRequest(request, responseType) {\n  let unwrappedRequest = typeof request === 'function' ? request() : request;\n  if (unwrappedRequest === undefined) {\n    return undefined;\n  } else if (typeof unwrappedRequest === 'string') {\n    unwrappedRequest = {\n      url: unwrappedRequest\n    };\n  }\n  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);\n  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({\n    fromObject: unwrappedRequest.params\n  });\n  return new HttpRequest(unwrappedRequest.method ?? 'GET', unwrappedRequest.url, unwrappedRequest.body ?? null, {\n    headers,\n    params,\n    reportProgress: unwrappedRequest.reportProgress,\n    withCredentials: unwrappedRequest.withCredentials,\n    keepalive: unwrappedRequest.keepalive,\n    cache: unwrappedRequest.cache,\n    priority: unwrappedRequest.priority,\n    mode: unwrappedRequest.mode,\n    redirect: unwrappedRequest.redirect,\n    responseType,\n    context: unwrappedRequest.context,\n    transferCache: unwrappedRequest.transferCache,\n    credentials: unwrappedRequest.credentials,\n    referrer: unwrappedRequest.referrer,\n    referrerPolicy: unwrappedRequest.referrerPolicy,\n    integrity: unwrappedRequest.integrity,\n    timeout: unwrappedRequest.timeout\n  });\n}\nclass HttpResourceImpl extends _ResourceImpl {\n  client;\n  _headers = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_headers\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  _progress = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_progress\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  _statusCode = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_statusCode\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  headers = /*#__PURE__*/computed(() => this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined, ...(ngDevMode ? [{\n    debugName: \"headers\"\n  }] : []));\n  progress = /*#__PURE__*/this._progress.asReadonly();\n  statusCode = /*#__PURE__*/this._statusCode.asReadonly();\n  constructor(injector, request, defaultValue, debugName, parse, equal) {\n    super(request, ({\n      params: request,\n      abortSignal\n    }) => {\n      let sub;\n      const onAbort = () => sub.unsubscribe();\n      abortSignal.addEventListener('abort', onAbort);\n      const stream = signal({\n        value: undefined\n      }, ...(ngDevMode ? [{\n        debugName: \"stream\"\n      }] : []));\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      const send = value => {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      };\n      sub = this.client.request(request).subscribe({\n        next: event => {\n          switch (event.type) {\n            case HttpEventType.Response:\n              this._headers.set(event.headers);\n              this._statusCode.set(event.status);\n              try {\n                send({\n                  value: parse ? parse(event.body) : event.body\n                });\n              } catch (error) {\n                send({\n                  error: _encapsulateResourceError(error)\n                });\n              }\n              break;\n            case HttpEventType.DownloadProgress:\n              this._progress.set(event);\n              break;\n          }\n        },\n        error: error => {\n          if (error instanceof HttpErrorResponse) {\n            this._headers.set(error.headers);\n            this._statusCode.set(error.status);\n          }\n          send({\n            error\n          });\n          abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new _RuntimeError(991, ngDevMode && 'Resource completed before producing a value')\n            });\n          }\n          abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }, defaultValue, equal, debugName, injector);\n    this.client = injector.get(HttpClient);\n  }\n  set(value) {\n    super.set(value);\n    this._headers.set(undefined);\n    this._progress.set(undefined);\n    this._statusCode.set(undefined);\n  }\n}\nconst HTTP_TRANSFER_CACHE_ORIGIN_MAP = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_CACHE_ORIGIN_MAP' : '');\nconst BODY = 'b';\nconst HEADERS = 'h';\nconst STATUS = 's';\nconst STATUS_TEXT = 'st';\nconst REQ_URL = 'u';\nconst RESPONSE_TYPE = 'rt';\nconst CACHE_OPTIONS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');\nconst ALLOWED_METHODS = ['GET', 'HEAD'];\nfunction transferCacheInterceptorFn(req, next) {\n  const {\n    isCacheActive,\n    ...globalOptions\n  } = inject(CACHE_OPTIONS);\n  const {\n    transferCache: requestOptions,\n    method: requestMethod\n  } = req;\n  if (!isCacheActive || requestOptions === false || requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions || requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod) || !globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req) || globalOptions.filter?.(req) === false) {\n    return next(req);\n  }\n  const transferState = inject(TransferState);\n  const originMap = inject(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {\n    optional: true\n  });\n  if (typeof ngServerMode !== 'undefined' && !ngServerMode && originMap) {\n    throw new _RuntimeError(2803, ngDevMode && 'Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and ' + 'present in the client side code. Please ensure that this token is only provided in the ' + 'server code of the application.');\n  }\n  const requestUrl = typeof ngServerMode !== 'undefined' && ngServerMode && originMap ? mapRequestOriginUrl(req.url, originMap) : req.url;\n  const storeKey = makeCacheKey(req, requestUrl);\n  const response = transferState.get(storeKey, null);\n  let headersToInclude = globalOptions.includeHeaders;\n  if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {\n    headersToInclude = requestOptions.includeHeaders;\n  }\n  if (response) {\n    const {\n      [BODY]: undecodedBody,\n      [RESPONSE_TYPE]: responseType,\n      [HEADERS]: httpHeaders,\n      [STATUS]: status,\n      [STATUS_TEXT]: statusText,\n      [REQ_URL]: url\n    } = response;\n    let body = undecodedBody;\n    switch (responseType) {\n      case 'arraybuffer':\n        body = new TextEncoder().encode(undecodedBody).buffer;\n        break;\n      case 'blob':\n        body = new Blob([undecodedBody]);\n        break;\n    }\n    let headers = new HttpHeaders(httpHeaders);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);\n    }\n    return of(new HttpResponse({\n      body,\n      headers,\n      status,\n      statusText,\n      url\n    }));\n  }\n  const event$ = next(req);\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return event$.pipe(tap(event => {\n      if (event instanceof HttpResponse) {\n        transferState.set(storeKey, {\n          [BODY]: event.body,\n          [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),\n          [STATUS]: event.status,\n          [STATUS_TEXT]: event.statusText,\n          [REQ_URL]: requestUrl,\n          [RESPONSE_TYPE]: req.responseType\n        });\n      }\n    }));\n  }\n  return event$;\n}\nfunction hasAuthHeaders(req) {\n  return req.headers.has('authorization') || req.headers.has('proxy-authorization');\n}\nfunction getFilteredHeaders(headers, includeHeaders) {\n  if (!includeHeaders) {\n    return {};\n  }\n  const headersMap = {};\n  for (const key of includeHeaders) {\n    const values = headers.getAll(key);\n    if (values !== null) {\n      headersMap[key] = values;\n    }\n  }\n  return headersMap;\n}\nfunction sortAndConcatParams(params) {\n  return [...params.keys()].sort().map(k => `${k}=${params.getAll(k)}`).join('&');\n}\nfunction makeCacheKey(request, mappedRequestUrl) {\n  const {\n    params,\n    method,\n    responseType\n  } = request;\n  const encodedParams = sortAndConcatParams(params);\n  let serializedBody = request.serializeBody();\n  if (serializedBody instanceof URLSearchParams) {\n    serializedBody = sortAndConcatParams(serializedBody);\n  } else if (typeof serializedBody !== 'string') {\n    serializedBody = '';\n  }\n  const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join('|');\n  const hash = generateHash(key);\n  return makeStateKey(hash);\n}\nfunction generateHash(value) {\n  let hash = 0;\n  for (const char of value) {\n    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n  }\n  hash += 2147483647 + 1;\n  return hash.toString();\n}\nfunction withHttpTransferCache(cacheOptions) {\n  return [{\n    provide: CACHE_OPTIONS,\n    useFactory: () => {\n      _performanceMarkFeature('NgHttpTransferCache');\n      return {\n        isCacheActive: true,\n        ...cacheOptions\n      };\n    }\n  }, {\n    provide: HTTP_ROOT_INTERCEPTOR_FNS,\n    useValue: transferCacheInterceptorFn,\n    multi: true\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: () => {\n      const appRef = inject(ApplicationRef);\n      const cacheState = inject(CACHE_OPTIONS);\n      return () => {\n        appRef.whenStable().then(() => {\n          cacheState.isCacheActive = false;\n        });\n      };\n    }\n  }];\n}\nfunction appendMissingHeadersDetection(url, headers, headersToInclude) {\n  const warningProduced = new Set();\n  return new Proxy(headers, {\n    get(target, prop) {\n      const value = Reflect.get(target, prop);\n      const methods = new Set(['get', 'has', 'getAll']);\n      if (typeof value !== 'function' || !methods.has(prop)) {\n        return value;\n      }\n      return headerName => {\n        const key = (prop + ':' + headerName).toLowerCase();\n        if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {\n          warningProduced.add(key);\n          const truncatedUrl = _truncateMiddle(url);\n          console.warn(_formatRuntimeError(-2802, `Angular detected that the \\`${headerName}\\` header is accessed, but the value of the header ` + `was not transferred from the server to the client by the HttpTransferCache. ` + `To include the value of the \\`${headerName}\\` header for the \\`${truncatedUrl}\\` request, ` + `use the \\`includeHeaders\\` list. The \\`includeHeaders\\` can be defined either ` + `on a request level by adding the \\`transferCache\\` parameter, or on an application ` + `level by adding the \\`httpCacheTransfer.includeHeaders\\` argument to the ` + `\\`provideClientHydration()\\` call. `));\n        }\n        return value.apply(target, [headerName]);\n      };\n    }\n  });\n}\nfunction mapRequestOriginUrl(url, originMap) {\n  const origin = new URL(url, 'resolve://').origin;\n  const mappedOrigin = originMap[origin];\n  if (!mappedOrigin) {\n    return url;\n  }\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    verifyMappedOrigin(mappedOrigin);\n  }\n  return url.replace(origin, mappedOrigin);\n}\nfunction verifyMappedOrigin(url) {\n  if (new URL(url, 'resolve://').pathname !== '/') {\n    throw new _RuntimeError(2804, 'Angular detected a URL with a path segment in the value provided for the ' + `\\`HTTP_TRANSFER_CACHE_ORIGIN_MAP\\` token: ${url}. The map should only contain origins ` + 'without any other segments.');\n  }\n}\nexport { HTTP_TRANSFER_CACHE_ORIGIN_MAP, HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpParams, HttpRequest, HttpResponse, httpResource, HTTP_ROOT_INTERCEPTOR_FNS as ɵHTTP_ROOT_INTERCEPTOR_FNS, withHttpTransferCache as ɵwithHttpTransferCache };","map":{"version":3,"names":["HttpHeaders","HttpParams","HttpRequest","HttpEventType","HttpErrorResponse","HttpClient","HTTP_ROOT_INTERCEPTOR_FNS","HttpResponse","FetchBackend","HTTP_INTERCEPTORS","HttpBackend","HttpClientJsonpModule","HttpClientModule","HttpClientXsrfModule","HttpContext","HttpContextToken","HttpFeatureKind","HttpHandler","HttpHeaderResponse","HttpResponseBase","HttpStatusCode","HttpUrlEncodingCodec","HttpXhrBackend","HttpXsrfTokenExtractor","JsonpClientBackend","JsonpInterceptor","provideHttpClient","withFetch","withInterceptors","withInterceptorsFromDi","withJsonpSupport","withNoXsrfProtection","withRequestsMadeViaParent","withXsrfConfiguration","HttpInterceptorHandler","ɵHttpInterceptingHandler","REQUESTS_CONTRIBUTE_TO_STABILITY","ɵREQUESTS_CONTRIBUTE_TO_STABILITY","assertInInjectionContext","inject","Injector","ɵResourceImpl","_ResourceImpl","linkedSignal","computed","signal","ɵencapsulateResourceError","_encapsulateResourceError","ɵRuntimeError","_RuntimeError","InjectionToken","ɵperformanceMarkFeature","_performanceMarkFeature","APP_BOOTSTRAP_LISTENER","ApplicationRef","TransferState","makeStateKey","ɵtruncateMiddle","_truncateMiddle","ɵformatRuntimeError","_formatRuntimeError","of","tap","httpResource","jsonFn","makeHttpResourceFn","arrayBuffer","blob","text","responseType","request","options","ngDevMode","injector","HttpResourceImpl","normalizeRequest","defaultValue","debugName","parse","equal","unwrappedRequest","undefined","url","headers","params","fromObject","method","body","reportProgress","withCredentials","keepalive","cache","priority","mode","redirect","context","transferCache","credentials","referrer","referrerPolicy","integrity","timeout","client","_headers","source","extRequest","computation","_progress","_statusCode","status","progress","asReadonly","statusCode","constructor","abortSignal","sub","onAbort","unsubscribe","addEventListener","stream","value","resolve","promise","Promise","r","send","set","subscribe","next","event","type","Response","error","DownloadProgress","removeEventListener","complete","get","HTTP_TRANSFER_CACHE_ORIGIN_MAP","BODY","HEADERS","STATUS","STATUS_TEXT","REQ_URL","RESPONSE_TYPE","CACHE_OPTIONS","ALLOWED_METHODS","transferCacheInterceptorFn","req","isCacheActive","globalOptions","requestOptions","requestMethod","includePostRequests","includes","includeRequestsWithAuthHeaders","hasAuthHeaders","filter","transferState","originMap","optional","ngServerMode","requestUrl","mapRequestOriginUrl","storeKey","makeCacheKey","response","headersToInclude","includeHeaders","undecodedBody","httpHeaders","statusText","TextEncoder","encode","buffer","Blob","appendMissingHeadersDetection","event$","pipe","getFilteredHeaders","has","headersMap","key","values","getAll","sortAndConcatParams","keys","sort","map","k","join","mappedRequestUrl","encodedParams","serializedBody","serializeBody","URLSearchParams","hash","generateHash","char","Math","imul","charCodeAt","toString","withHttpTransferCache","cacheOptions","provide","useFactory","useValue","multi","appRef","cacheState","whenStable","then","warningProduced","Set","Proxy","target","prop","Reflect","methods","headerName","toLowerCase","add","truncatedUrl","console","warn","apply","origin","URL","mappedOrigin","verifyMappedOrigin","replace","pathname","ɵHTTP_ROOT_INTERCEPTOR_FNS","ɵwithHttpTransferCache"],"sources":["/Users/ariez/Downloads/crud/node_modules/@angular/common/fesm2022/http.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { HttpHeaders, HttpParams, HttpRequest, HttpEventType, HttpErrorResponse, HttpClient, HTTP_ROOT_INTERCEPTOR_FNS, HttpResponse } from './_module-chunk.mjs';\nexport { FetchBackend, HTTP_INTERCEPTORS, HttpBackend, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration, HttpInterceptorHandler as ɵHttpInterceptingHandler, REQUESTS_CONTRIBUTE_TO_STABILITY as ɵREQUESTS_CONTRIBUTE_TO_STABILITY } from './_module-chunk.mjs';\nimport { assertInInjectionContext, inject, Injector, ɵResourceImpl as _ResourceImpl, linkedSignal, computed, signal, ɵencapsulateResourceError as _encapsulateResourceError, ɵRuntimeError as _RuntimeError, InjectionToken, ɵperformanceMarkFeature as _performanceMarkFeature, APP_BOOTSTRAP_LISTENER, ApplicationRef, TransferState, makeStateKey, ɵtruncateMiddle as _truncateMiddle, ɵformatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { of } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport './_xhr-chunk.mjs';\nimport './_platform_location-chunk.mjs';\n\nconst httpResource = (() => {\n  const jsonFn = makeHttpResourceFn('json');\n  jsonFn.arrayBuffer = makeHttpResourceFn('arraybuffer');\n  jsonFn.blob = makeHttpResourceFn('blob');\n  jsonFn.text = makeHttpResourceFn('text');\n  return jsonFn;\n})();\nfunction makeHttpResourceFn(responseType) {\n  return function httpResource(request, options) {\n    if (ngDevMode && !options?.injector) {\n      assertInInjectionContext(httpResource);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.debugName, options?.parse, options?.equal);\n  };\n}\nfunction normalizeRequest(request, responseType) {\n  let unwrappedRequest = typeof request === 'function' ? request() : request;\n  if (unwrappedRequest === undefined) {\n    return undefined;\n  } else if (typeof unwrappedRequest === 'string') {\n    unwrappedRequest = {\n      url: unwrappedRequest\n    };\n  }\n  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);\n  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({\n    fromObject: unwrappedRequest.params\n  });\n  return new HttpRequest(unwrappedRequest.method ?? 'GET', unwrappedRequest.url, unwrappedRequest.body ?? null, {\n    headers,\n    params,\n    reportProgress: unwrappedRequest.reportProgress,\n    withCredentials: unwrappedRequest.withCredentials,\n    keepalive: unwrappedRequest.keepalive,\n    cache: unwrappedRequest.cache,\n    priority: unwrappedRequest.priority,\n    mode: unwrappedRequest.mode,\n    redirect: unwrappedRequest.redirect,\n    responseType,\n    context: unwrappedRequest.context,\n    transferCache: unwrappedRequest.transferCache,\n    credentials: unwrappedRequest.credentials,\n    referrer: unwrappedRequest.referrer,\n    referrerPolicy: unwrappedRequest.referrerPolicy,\n    integrity: unwrappedRequest.integrity,\n    timeout: unwrappedRequest.timeout\n  });\n}\nclass HttpResourceImpl extends _ResourceImpl {\n  client;\n  _headers = linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_headers\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  _progress = linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_progress\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  _statusCode = linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"_statusCode\"\n    } : {}),\n    source: this.extRequest,\n    computation: () => undefined\n  });\n  headers = computed(() => this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined, ...(ngDevMode ? [{\n    debugName: \"headers\"\n  }] : []));\n  progress = this._progress.asReadonly();\n  statusCode = this._statusCode.asReadonly();\n  constructor(injector, request, defaultValue, debugName, parse, equal) {\n    super(request, ({\n      params: request,\n      abortSignal\n    }) => {\n      let sub;\n      const onAbort = () => sub.unsubscribe();\n      abortSignal.addEventListener('abort', onAbort);\n      const stream = signal({\n        value: undefined\n      }, ...(ngDevMode ? [{\n        debugName: \"stream\"\n      }] : []));\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      const send = value => {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      };\n      sub = this.client.request(request).subscribe({\n        next: event => {\n          switch (event.type) {\n            case HttpEventType.Response:\n              this._headers.set(event.headers);\n              this._statusCode.set(event.status);\n              try {\n                send({\n                  value: parse ? parse(event.body) : event.body\n                });\n              } catch (error) {\n                send({\n                  error: _encapsulateResourceError(error)\n                });\n              }\n              break;\n            case HttpEventType.DownloadProgress:\n              this._progress.set(event);\n              break;\n          }\n        },\n        error: error => {\n          if (error instanceof HttpErrorResponse) {\n            this._headers.set(error.headers);\n            this._statusCode.set(error.status);\n          }\n          send({\n            error\n          });\n          abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new _RuntimeError(991, ngDevMode && 'Resource completed before producing a value')\n            });\n          }\n          abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }, defaultValue, equal, debugName, injector);\n    this.client = injector.get(HttpClient);\n  }\n  set(value) {\n    super.set(value);\n    this._headers.set(undefined);\n    this._progress.set(undefined);\n    this._statusCode.set(undefined);\n  }\n}\n\nconst HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_CACHE_ORIGIN_MAP' : '');\nconst BODY = 'b';\nconst HEADERS = 'h';\nconst STATUS = 's';\nconst STATUS_TEXT = 'st';\nconst REQ_URL = 'u';\nconst RESPONSE_TYPE = 'rt';\nconst CACHE_OPTIONS = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');\nconst ALLOWED_METHODS = ['GET', 'HEAD'];\nfunction transferCacheInterceptorFn(req, next) {\n  const {\n    isCacheActive,\n    ...globalOptions\n  } = inject(CACHE_OPTIONS);\n  const {\n    transferCache: requestOptions,\n    method: requestMethod\n  } = req;\n  if (!isCacheActive || requestOptions === false || requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions || requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod) || !globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req) || globalOptions.filter?.(req) === false) {\n    return next(req);\n  }\n  const transferState = inject(TransferState);\n  const originMap = inject(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {\n    optional: true\n  });\n  if (typeof ngServerMode !== 'undefined' && !ngServerMode && originMap) {\n    throw new _RuntimeError(2803, ngDevMode && 'Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and ' + 'present in the client side code. Please ensure that this token is only provided in the ' + 'server code of the application.');\n  }\n  const requestUrl = typeof ngServerMode !== 'undefined' && ngServerMode && originMap ? mapRequestOriginUrl(req.url, originMap) : req.url;\n  const storeKey = makeCacheKey(req, requestUrl);\n  const response = transferState.get(storeKey, null);\n  let headersToInclude = globalOptions.includeHeaders;\n  if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {\n    headersToInclude = requestOptions.includeHeaders;\n  }\n  if (response) {\n    const {\n      [BODY]: undecodedBody,\n      [RESPONSE_TYPE]: responseType,\n      [HEADERS]: httpHeaders,\n      [STATUS]: status,\n      [STATUS_TEXT]: statusText,\n      [REQ_URL]: url\n    } = response;\n    let body = undecodedBody;\n    switch (responseType) {\n      case 'arraybuffer':\n        body = new TextEncoder().encode(undecodedBody).buffer;\n        break;\n      case 'blob':\n        body = new Blob([undecodedBody]);\n        break;\n    }\n    let headers = new HttpHeaders(httpHeaders);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);\n    }\n    return of(new HttpResponse({\n      body,\n      headers,\n      status,\n      statusText,\n      url\n    }));\n  }\n  const event$ = next(req);\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return event$.pipe(tap(event => {\n      if (event instanceof HttpResponse) {\n        transferState.set(storeKey, {\n          [BODY]: event.body,\n          [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),\n          [STATUS]: event.status,\n          [STATUS_TEXT]: event.statusText,\n          [REQ_URL]: requestUrl,\n          [RESPONSE_TYPE]: req.responseType\n        });\n      }\n    }));\n  }\n  return event$;\n}\nfunction hasAuthHeaders(req) {\n  return req.headers.has('authorization') || req.headers.has('proxy-authorization');\n}\nfunction getFilteredHeaders(headers, includeHeaders) {\n  if (!includeHeaders) {\n    return {};\n  }\n  const headersMap = {};\n  for (const key of includeHeaders) {\n    const values = headers.getAll(key);\n    if (values !== null) {\n      headersMap[key] = values;\n    }\n  }\n  return headersMap;\n}\nfunction sortAndConcatParams(params) {\n  return [...params.keys()].sort().map(k => `${k}=${params.getAll(k)}`).join('&');\n}\nfunction makeCacheKey(request, mappedRequestUrl) {\n  const {\n    params,\n    method,\n    responseType\n  } = request;\n  const encodedParams = sortAndConcatParams(params);\n  let serializedBody = request.serializeBody();\n  if (serializedBody instanceof URLSearchParams) {\n    serializedBody = sortAndConcatParams(serializedBody);\n  } else if (typeof serializedBody !== 'string') {\n    serializedBody = '';\n  }\n  const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join('|');\n  const hash = generateHash(key);\n  return makeStateKey(hash);\n}\nfunction generateHash(value) {\n  let hash = 0;\n  for (const char of value) {\n    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n  }\n  hash += 2147483647 + 1;\n  return hash.toString();\n}\nfunction withHttpTransferCache(cacheOptions) {\n  return [{\n    provide: CACHE_OPTIONS,\n    useFactory: () => {\n      _performanceMarkFeature('NgHttpTransferCache');\n      return {\n        isCacheActive: true,\n        ...cacheOptions\n      };\n    }\n  }, {\n    provide: HTTP_ROOT_INTERCEPTOR_FNS,\n    useValue: transferCacheInterceptorFn,\n    multi: true\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: () => {\n      const appRef = inject(ApplicationRef);\n      const cacheState = inject(CACHE_OPTIONS);\n      return () => {\n        appRef.whenStable().then(() => {\n          cacheState.isCacheActive = false;\n        });\n      };\n    }\n  }];\n}\nfunction appendMissingHeadersDetection(url, headers, headersToInclude) {\n  const warningProduced = new Set();\n  return new Proxy(headers, {\n    get(target, prop) {\n      const value = Reflect.get(target, prop);\n      const methods = new Set(['get', 'has', 'getAll']);\n      if (typeof value !== 'function' || !methods.has(prop)) {\n        return value;\n      }\n      return headerName => {\n        const key = (prop + ':' + headerName).toLowerCase();\n        if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {\n          warningProduced.add(key);\n          const truncatedUrl = _truncateMiddle(url);\n          console.warn(_formatRuntimeError(-2802, `Angular detected that the \\`${headerName}\\` header is accessed, but the value of the header ` + `was not transferred from the server to the client by the HttpTransferCache. ` + `To include the value of the \\`${headerName}\\` header for the \\`${truncatedUrl}\\` request, ` + `use the \\`includeHeaders\\` list. The \\`includeHeaders\\` can be defined either ` + `on a request level by adding the \\`transferCache\\` parameter, or on an application ` + `level by adding the \\`httpCacheTransfer.includeHeaders\\` argument to the ` + `\\`provideClientHydration()\\` call. `));\n        }\n        return value.apply(target, [headerName]);\n      };\n    }\n  });\n}\nfunction mapRequestOriginUrl(url, originMap) {\n  const origin = new URL(url, 'resolve://').origin;\n  const mappedOrigin = originMap[origin];\n  if (!mappedOrigin) {\n    return url;\n  }\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    verifyMappedOrigin(mappedOrigin);\n  }\n  return url.replace(origin, mappedOrigin);\n}\nfunction verifyMappedOrigin(url) {\n  if (new URL(url, 'resolve://').pathname !== '/') {\n    throw new _RuntimeError(2804, 'Angular detected a URL with a path segment in the value provided for the ' + `\\`HTTP_TRANSFER_CACHE_ORIGIN_MAP\\` token: ${url}. The map should only contain origins ` + 'without any other segments.');\n  }\n}\n\nexport { HTTP_TRANSFER_CACHE_ORIGIN_MAP, HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpParams, HttpRequest, HttpResponse, httpResource, HTTP_ROOT_INTERCEPTOR_FNS as ɵHTTP_ROOT_INTERCEPTOR_FNS, withHttpTransferCache as ɵwithHttpTransferCache };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}