{"ast":null,"code":"/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { getActiveConsumer, setActiveConsumer as setActiveConsumer$1, createSignal, SIGNAL, consumerDestroy, BASE_EFFECT_NODE, isInNotificationPhase, runEffect, untracked as untracked$1 } from './_effect-chunk.mjs';\nimport { BehaviorSubject, Observable, Subject, Subscription } from 'rxjs';\nimport { isNotFound, getCurrentInjector, setCurrentInjector } from './_not_found-chunk.mjs';\nimport { setActiveConsumer } from '@angular/core/primitives/signals';\nimport { isNotFound as isNotFound$1 } from '@angular/core/primitives/di';\nclass Version {\n  full;\n  major;\n  minor;\n  patch;\n  constructor(full) {\n    this.full = full;\n    const parts = full.split('.');\n    this.major = parts[0];\n    this.minor = parts[1];\n    this.patch = parts.slice(2).join('.');\n  }\n}\nconst VERSION = /* @__PURE__ */new Version('21.0.6');\nconst ERROR_DETAILS_PAGE_BASE_URL = /*#__PURE__*/(() => {\n  const versionSubDomain = VERSION.major !== '0' ? `v${VERSION.major}.` : '';\n  return `https://${versionSubDomain}angular.dev/errors`;\n})();\nconst XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';\nclass RuntimeError extends Error {\n  code;\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\nfunction formatRuntimeErrorCode(code) {\n  return `NG0${Math.abs(code)}`;\n}\nfunction formatRuntimeError(code, message) {\n  const fullCode = formatRuntimeErrorCode(code);\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\nconst _global = globalThis;\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0,\n    deferBlocksWithIncrementalHydration: 0\n  };\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  if (!allowNgDevModeTrue) {\n    _global['ngDevMode'] = false;\n  } else {\n    if (typeof _global['ngDevMode'] !== 'object') {\n      _global['ngDevMode'] = {};\n    }\n    Object.assign(_global['ngDevMode'], newCounters);\n  }\n  return newCounters;\n}\nfunction initNgDevMode() {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n      return key;\n    }\n  }\n  throw Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Could not find renamed property on target object.' : '');\n}\nfunction fillProperties(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n  const result = token.toString();\n  if (result == null) {\n    return '' + result;\n  }\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\nfunction concatStringsWithSpace(before, after) {\n  if (!before) return after || '';\n  if (!after) return before;\n  return `${before} ${after}`;\n}\nfunction truncateMiddle(str, maxLength = 100) {\n  if (!str || maxLength < 1 || str.length <= maxLength) return str;\n  if (maxLength == 1) return str.substring(0, 1) + '...';\n  const halfLimit = Math.round(maxLength / 2);\n  return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);\n}\nconst __forward_ref__ = /*#__PURE__*/getClosureSafeProperty({\n  __forward_ref__: getClosureSafeProperty\n});\nfunction forwardRef(forwardRefFn) {\n  forwardRefFn.__forward_ref__ = forwardRef;\n  forwardRefFn.toString = function () {\n    return stringify(this());\n  };\n  return forwardRefFn;\n}\nfunction resolveForwardRef(type) {\n  return isForwardRef(type) ? type() : type;\n}\nfunction isForwardRef(fn) {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;\n}\nfunction assertNumber(actual, msg) {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\nfunction assertFunction(actual, msg) {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\nfunction assertEqual(actual, expected, msg) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\nfunction assertNotEqual(actual, expected, msg) {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\nfunction assertSame(actual, expected, msg) {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\nfunction assertNotSame(actual, expected, msg) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\nfunction assertLessThan(actual, expected, msg) {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\nfunction assertNotDefined(actual, msg) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\nfunction assertDefined(actual, msg) {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\nfunction throwError(msg, actual, expected, comparison) {\n  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n  if (!(node instanceof Node)) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\nfunction assertElement(node) {\n  if (!(node instanceof Element)) {\n    throwError(`The provided value must be an element but got ${stringify(node)}`);\n  }\n}\nfunction assertIndexInRange(arr, index) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\nfunction assertOneOf(value, ...validValues) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\nfunction assertNotReactive(fn) {\n  if (getActiveConsumer() !== null) {\n    throwError(`${fn}() should never be called in a reactive context.`);\n  }\n}\nfunction ɵɵdefineInjectable(opts) {\n  return {\n    token: opts.token,\n    providedIn: opts.providedIn || null,\n    factory: opts.factory,\n    value: undefined\n  };\n}\nfunction ɵɵdefineInjector(options) {\n  return {\n    providers: options.providers || [],\n    imports: options.imports || []\n  };\n}\nfunction getInjectableDef(type) {\n  return getOwnDefinition(type, NG_PROV_DEF);\n}\nfunction isInjectable(type) {\n  return getInjectableDef(type) !== null;\n}\nfunction getOwnDefinition(type, field) {\n  return type.hasOwnProperty(field) && type[field] || null;\n}\nfunction getInheritedInjectableDef(type) {\n  const def = type?.[NG_PROV_DEF] ?? null;\n  if (def) {\n    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\nfunction getInjectorDef(type) {\n  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;\n}\nconst NG_PROV_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵprov: getClosureSafeProperty\n});\nconst NG_INJ_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵinj: getClosureSafeProperty\n});\nclass InjectionToken {\n  _desc;\n  ngMetadataName = 'InjectionToken';\n  ɵprov;\n  constructor(_desc, options) {\n    this._desc = _desc;\n    this.ɵprov = undefined;\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');\n      this.__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory\n      });\n    }\n  }\n  get multi() {\n    return this;\n  }\n  toString() {\n    return `InjectionToken ${this._desc}`;\n  }\n}\nlet _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n  return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context) {\n  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n  const previous = _injectorProfilerContext;\n  _injectorProfilerContext = context;\n  return previous;\n}\nconst injectorProfilerCallbacks = [];\nconst NOOP_PROFILER_REMOVAL = () => {};\nfunction removeProfiler(profiler) {\n  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\n  if (profilerIdx !== -1) {\n    injectorProfilerCallbacks.splice(profilerIdx, 1);\n  }\n}\nfunction setInjectorProfiler(injectorProfiler) {\n  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n  if (injectorProfiler !== null) {\n    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\n      injectorProfilerCallbacks.push(injectorProfiler);\n    }\n    return () => removeProfiler(injectorProfiler);\n  } else {\n    injectorProfilerCallbacks.length = 0;\n    return NOOP_PROFILER_REMOVAL;\n  }\n}\nfunction injectorProfiler(event) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\n    const injectorProfilerCallback = injectorProfilerCallbacks[i];\n    injectorProfilerCallback(event);\n  }\n}\nfunction emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  let token;\n  if (typeof eventProvider === 'function') {\n    token = eventProvider;\n  } else if (eventProvider instanceof InjectionToken) {\n    token = eventProvider;\n  } else {\n    token = resolveForwardRef(eventProvider.provide);\n  }\n  let provider = eventProvider;\n  if (eventProvider instanceof InjectionToken) {\n    provider = eventProvider.ɵprov || eventProvider;\n  }\n  injectorProfiler({\n    type: 2,\n    context: getInjectorProfilerContext(),\n    providerRecord: {\n      token,\n      provider,\n      isViewProvider\n    }\n  });\n}\nfunction emitInjectorToCreateInstanceEvent(token) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 5,\n    context: getInjectorProfilerContext(),\n    token: token\n  });\n}\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 1,\n    context: getInjectorProfilerContext(),\n    instance: {\n      value: instance\n    }\n  });\n}\nfunction emitInjectEvent(token, value, flags) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 0,\n    context: getInjectorProfilerContext(),\n    service: {\n      token,\n      value,\n      flags\n    }\n  });\n}\nfunction emitEffectCreatedEvent(effect) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 3,\n    context: getInjectorProfilerContext(),\n    effect\n  });\n}\nfunction emitAfterRenderEffectPhaseCreatedEvent(effectPhase) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 4,\n    context: getInjectorProfilerContext(),\n    effectPhase\n  });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n  !ngDevMode && throwError('runInInjectorProfilerContext should never be called in production mode');\n  const prevInjectContext = setInjectorProfilerContext({\n    injector,\n    token\n  });\n  try {\n    callback();\n  } finally {\n    setInjectorProfilerContext(prevInjectContext);\n  }\n}\nfunction isEnvironmentProviders(value) {\n  return value && !!value.ɵproviders;\n}\nconst NG_COMP_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵcmp: getClosureSafeProperty\n});\nconst NG_DIR_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵdir: getClosureSafeProperty\n});\nconst NG_PIPE_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵpipe: getClosureSafeProperty\n});\nconst NG_MOD_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵmod: getClosureSafeProperty\n});\nconst NG_FACTORY_DEF = /*#__PURE__*/getClosureSafeProperty({\n  ɵfac: getClosureSafeProperty\n});\nconst NG_ELEMENT_ID = /*#__PURE__*/getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty\n});\nconst NG_ENV_ID = /*#__PURE__*/getClosureSafeProperty({\n  __NG_ENV_ID__: getClosureSafeProperty\n});\nfunction getNgModuleDef(type) {\n  assertTypeDefined(type, '@NgModule');\n  return type[NG_MOD_DEF] || null;\n}\nfunction getNgModuleDefOrThrow(type) {\n  const ngModuleDef = getNgModuleDef(type);\n  if (!ngModuleDef) {\n    throw new RuntimeError(915, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n  return ngModuleDef;\n}\nfunction getComponentDef(type) {\n  assertTypeDefined(type, '@Component');\n  return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDefOrThrow(type) {\n  const def = getDirectiveDef(type);\n  if (!def) {\n    throw new RuntimeError(916, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵdir' property.`);\n  }\n  return def;\n}\nfunction getDirectiveDef(type) {\n  assertTypeDefined(type, '@Directive');\n  return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef(type) {\n  assertTypeDefined(type, '@Pipe');\n  return type[NG_PIPE_DEF] || null;\n}\nfunction assertTypeDefined(type, symbolType) {\n  if (type == null) {\n    throw new RuntimeError(-919, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot read ${symbolType} metadata. This can indicate a runtime ` + `circular dependency in your app that needs to be resolved.`);\n  }\n}\nfunction isStandalone(type) {\n  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n  return def !== null && def.standalone;\n}\nfunction renderStringify(value) {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  return String(value);\n}\nfunction stringifyForError(value) {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n  return renderStringify(value);\n}\nfunction debugStringifyTypeForError(type) {\n  const componentDef = getComponentDef(type);\n  if (componentDef !== null && componentDef.debugInfo) {\n    return stringifyTypeFromDebugInfo(componentDef.debugInfo);\n  }\n  return stringifyForError(type);\n}\nfunction stringifyTypeFromDebugInfo(debugInfo) {\n  if (!debugInfo.filePath || !debugInfo.lineNumber) {\n    return debugInfo.className;\n  } else {\n    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;\n  }\n}\nconst NG_RUNTIME_ERROR_CODE = /*#__PURE__*/getClosureSafeProperty({\n  'ngErrorCode': getClosureSafeProperty\n});\nconst NG_RUNTIME_ERROR_MESSAGE = /*#__PURE__*/getClosureSafeProperty({\n  'ngErrorMessage': getClosureSafeProperty\n});\nconst NG_TOKEN_PATH = /*#__PURE__*/getClosureSafeProperty({\n  'ngTokenPath': getClosureSafeProperty\n});\nfunction cyclicDependencyError(token, path) {\n  const message = ngDevMode ? `Circular dependency detected for \\`${token}\\`.` : '';\n  return createRuntimeError(message, -200, path);\n}\nfunction cyclicDependencyErrorWithDetails(token, path) {\n  return augmentRuntimeError(cyclicDependencyError(token, path), null);\n}\nfunction throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n  } else if (isEnvironmentProviders(provider)) {\n    if (provider.ɵfromNgModule) {\n      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    } else {\n      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n    }\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\nfunction throwProviderNotFoundError(token, injectorName) {\n  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;\n  throw new RuntimeError(-201, errorMessage);\n}\nfunction prependTokenToDependencyPath(error, token) {\n  error[NG_TOKEN_PATH] ??= [];\n  const currentPath = error[NG_TOKEN_PATH];\n  let pathStr;\n  if (typeof token === 'object' && 'multi' in token && token?.multi === true) {\n    assertDefined(token.provide, 'Token with multi: true should have a provide property');\n    pathStr = stringifyForError(token.provide);\n  } else {\n    pathStr = stringifyForError(token);\n  }\n  if (currentPath[0] !== pathStr) {\n    error[NG_TOKEN_PATH].unshift(pathStr);\n  }\n}\nfunction augmentRuntimeError(error, source) {\n  const tokenPath = error[NG_TOKEN_PATH];\n  const errorCode = error[NG_RUNTIME_ERROR_CODE];\n  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;\n  error.message = formatErrorMessage(message, errorCode, tokenPath, source);\n  return error;\n}\nfunction createRuntimeError(message, code, path) {\n  const error = new RuntimeError(code, message);\n  error[NG_RUNTIME_ERROR_CODE] = code;\n  error[NG_RUNTIME_ERROR_MESSAGE] = message;\n  if (path) {\n    error[NG_TOKEN_PATH] = path;\n  }\n  return error;\n}\nfunction getRuntimeErrorCode(error) {\n  return error[NG_RUNTIME_ERROR_CODE];\n}\nfunction formatErrorMessage(text, code, path = [], source = null) {\n  let pathDetails = '';\n  if (path && path.length > 1) {\n    pathDetails = ` Path: ${path.join(' -> ')}.`;\n  }\n  const sourceDetails = source ? ` Source: ${source}.` : '';\n  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);\n}\nlet _injectImplementation;\nfunction getInjectImplementation() {\n  return _injectImplementation;\n}\nfunction setInjectImplementation(impl) {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n  const injectableDef = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;\n  }\n  if (flags & 8) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(token, typeof ngDevMode !== 'undefined' && ngDevMode ? 'Injector' : '');\n}\nfunction assertInjectImplementationNotEqual(fn) {\n  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nclass RetrievingInjector {\n  injector;\n  constructor(injector) {\n    this.injector = injector;\n  }\n  retrieve(token, options) {\n    const flags = convertToBitFlags(options) || 0;\n    try {\n      return this.injector.get(token, flags & 8 ? null : THROW_IF_NOT_FOUND, flags);\n    } catch (e) {\n      if (isNotFound(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n}\nfunction injectInjectorOnly(token, flags = 0) {\n  const currentInjector = getCurrentInjector();\n  if (currentInjector === undefined) {\n    throw new RuntimeError(-203, ngDevMode && `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n  } else if (currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    const options = convertToInjectOptions(flags);\n    const value = currentInjector.retrieve(token, options);\n    ngDevMode && emitInjectEvent(token, value, flags);\n    if (isNotFound(value)) {\n      if (options.optional) {\n        return null;\n      }\n      throw value;\n    }\n    return value;\n  }\n}\nfunction ɵɵinject(token, flags = 0) {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\nfunction ɵɵinvalidFactoryDep(index) {\n  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\nfunction inject(token, options) {\n  return ɵɵinject(token, convertToBitFlags(options));\n}\nfunction convertToBitFlags(flags) {\n  if (typeof flags === 'undefined' || typeof flags === 'number') {\n    return flags;\n  }\n  return 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);\n}\nfunction convertToInjectOptions(flags) {\n  return {\n    optional: !!(flags & 8),\n    host: !!(flags & 1),\n    self: !!(flags & 2),\n    skipSelf: !!(flags & 4)\n  };\n}\nfunction injectArgs(types) {\n  const args = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(900, ngDevMode && 'Arguments array must have arguments.');\n      }\n      let type = undefined;\n      let flags = 0;\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          if (flag === -1) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n      args.push(ɵɵinject(type, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\nfunction attachInjectFlag(decorator, flag) {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\nfunction getInjectFlag(token) {\n  return token[DI_DECORATOR_FLAG];\n}\nfunction getFactoryDef(type, throwNotFound) {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\nfunction arrayEquals(a, b, identityAccessor) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA);\n      valueB = identityAccessor(valueB);\n    }\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction flatten(list) {\n  return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\nfunction removeFromArray(arr, index) {\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\nfunction newArray(size, value) {\n  const list = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value);\n  }\n  return list;\n}\nfunction arraySplice(array, index, count) {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop();\n  }\n}\nfunction arrayInsert2(array, index, value1, value2) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n  let end = array.length;\n  if (end == index) {\n    array.push(value1, value2);\n  } else if (end === 1) {\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\nfunction keyValueArraySet(keyValueArray, key, value) {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\nfunction keyValueArrayGet(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    return keyValueArray[index | 1];\n  }\n  return undefined;\n}\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n  return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\nfunction _arrayIndexOfSorted(array, value, shift) {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + (end - start >> 1);\n    const current = array[middle << shift];\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1;\n    }\n  }\n  return ~(end << shift);\n}\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && /*#__PURE__*/initNgDevMode()) {\n  /*#__PURE__*/Object.freeze(EMPTY_OBJ);\n  /*#__PURE__*/Object.freeze(EMPTY_ARRAY);\n}\nconst ENVIRONMENT_INITIALIZER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');\nconst INJECTOR$1 = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR' : '', -1);\nconst INJECTOR_DEF_TYPES = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR_DEF_TYPES' : '');\nclass NullInjector {\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const message = ngDevMode ? `No provider found for \\`${stringify(token)}\\`.` : '';\n      const error = createRuntimeError(message, -201);\n      error.name = 'ɵNotFound';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\nfunction makeEnvironmentProviders(providers) {\n  return {\n    ɵproviders: providers\n  };\n}\nfunction provideEnvironmentInitializer(initializerFn) {\n  return makeEnvironmentProviders([{\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useValue: initializerFn\n  }]);\n}\nfunction importProvidersFrom(...sources) {\n  return {\n    ɵproviders: internalImportProvidersFrom(true, sources),\n    ɵfromNgModule: true\n  };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n  const providersOut = [];\n  const dedup = new Set();\n  let injectorTypesWithProviders;\n  const collectProviders = provider => {\n    providersOut.push(provider);\n  };\n  deepForEach(sources, source => {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef(source);\n      if (cmpDef?.standalone) {\n        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n      }\n    }\n    const internalSource = source;\n    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n      injectorTypesWithProviders ||= [];\n      injectorTypesWithProviders.push(internalSource);\n    }\n  });\n  if (injectorTypesWithProviders !== undefined) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n  }\n  return providersOut;\n}\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {\n      ngModule,\n      providers\n    } = typesWithProviders[i];\n    deepForEachProvider(providers, provider => {\n      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n      visitor(provider, ngModule);\n    });\n  }\n}\nfunction walkProviderTree(container, visitor, parents, dedup) {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n  let defType = null;\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef(container);\n  if (!injDef && !cmpDef) {\n    const ngModule = container.ngModule;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule;\n    } else {\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container;\n  }\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify).concat(defName);\n    throw cyclicDependencyErrorWithDetails(defName, path);\n  }\n  const isDuplicate = dedup.has(defType);\n  if (cmpDef) {\n    if (isDuplicate) {\n      return false;\n    }\n    dedup.add(defType);\n    if (cmpDef.dependencies) {\n      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, visitor, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    if (injDef.imports != null && !isDuplicate) {\n      ngDevMode && parents.push(defType);\n      dedup.add(defType);\n      let importTypesWithProviders;\n      try {\n        deepForEach(injDef.imports, imported => {\n          if (walkProviderTree(imported, visitor, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        ngDevMode && parents.pop();\n      }\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n      }\n    }\n    if (!isDuplicate) {\n      const factory = getFactoryDef(defType) || (() => new defType());\n      visitor({\n        provide: defType,\n        useFactory: factory,\n        deps: EMPTY_ARRAY\n      }, defType);\n      visitor({\n        provide: INJECTOR_DEF_TYPES,\n        useValue: defType,\n        multi: true\n      }, defType);\n      visitor({\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => ɵɵinject(defType),\n        multi: true\n      }, defType);\n    }\n    const defProviders = injDef.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container;\n      deepForEachProvider(defProviders, provider => {\n        ngDevMode && validateProvider(provider, defProviders, injectorType);\n        visitor(provider, injectorType);\n      });\n    }\n  } else {\n    return false;\n  }\n  return defType !== container && container.providers !== undefined;\n}\nfunction validateProvider(provider, providers, containerType) {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {\n    return;\n  }\n  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\nfunction deepForEachProvider(providers, fn) {\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      deepForEachProvider(provider, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nconst USE_VALUE = /*#__PURE__*/getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isValueProvider(value) {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\nfunction isExistingProvider(value) {\n  return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n  return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n  return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n  return !!value.useClass;\n}\nconst INJECTOR_SCOPE = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Set Injector scope.' : '');\nconst NOT_YET = {};\nconst CIRCULAR = {};\nlet NULL_INJECTOR = undefined;\nfunction getNullInjector() {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\nclass EnvironmentInjector {}\nclass R3Injector extends EnvironmentInjector {\n  parent;\n  source;\n  scopes;\n  records = /*#__PURE__*/new Map();\n  _ngOnDestroyHooks = /*#__PURE__*/new Set();\n  _onDestroyHooks = [];\n  get destroyed() {\n    return this._destroyed;\n  }\n  _destroyed = false;\n  injectorDefTypes;\n  constructor(providers, parent, source, scopes) {\n    super();\n    this.parent = parent;\n    this.source = source;\n    this.scopes = scopes;\n    forEachSingleProvider(providers, provider => this.processProvider(provider));\n    this.records.set(INJECTOR$1, makeRecord(undefined, this));\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    }\n    const record = this.records.get(INJECTOR_SCOPE);\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value);\n    }\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, {\n      self: true\n    }));\n  }\n  retrieve(token, options) {\n    const flags = convertToBitFlags(options) || 0;\n    try {\n      return this.get(token, THROW_IF_NOT_FOUND, flags);\n    } catch (e) {\n      if (isNotFound$1(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  destroy() {\n    assertNotDestroyed(this);\n    this._destroyed = true;\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      const onDestroyHooks = this._onDestroyHooks;\n      this._onDestroyHooks = [];\n      for (const hook of onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  onDestroy(callback) {\n    assertNotDestroyed(this);\n    this._onDestroyHooks.push(callback);\n    return () => this.removeOnDestroy(callback);\n  }\n  runInContext(fn) {\n    assertNotDestroyed(this);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {\n    assertNotDestroyed(this);\n    if (token.hasOwnProperty(NG_ENV_ID)) {\n      return token[NG_ENV_ID](this);\n    }\n    const flags = convertToBitFlags(options);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: token\n      });\n    }\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (!(flags & 4)) {\n        let record = this.records.get(token);\n        if (record === undefined) {\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            if (ngDevMode) {\n              runInInjectorProfilerContext(this, token, () => {\n                emitProviderConfiguredEvent(token);\n              });\n            }\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        if (record != null) {\n          return this.hydrate(token, record, flags);\n        }\n      }\n      const nextInjector = !(flags & 2) ? this.parent : getNullInjector();\n      notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (error) {\n      const errorCode = getRuntimeErrorCode(error);\n      if (errorCode === -200 || errorCode === -201) {\n        if (ngDevMode) {\n          prependTokenToDependencyPath(error, token);\n          if (previousInjector) {\n            throw error;\n          } else {\n            throw augmentRuntimeError(error, this.source);\n          }\n        } else {\n          throw new RuntimeError(errorCode, null);\n        }\n      } else {\n        throw error;\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  resolveInjectorInitializers() {\n    const prevConsumer = setActiveConsumer(null);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, {\n        self: true\n      });\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(-209, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  toString() {\n    const tokens = [];\n    const records = this.records;\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n  processProvider(provider) {\n    provider = resolveForwardRef(provider);\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n    const record = providerToRecord(provider);\n    if (ngDevMode) {\n      runInInjectorProfilerContext(this, token, () => {\n        if (isValueProvider(provider)) {\n          emitInjectorToCreateInstanceEvent(token);\n          emitInstanceCreatedByInjectorEvent(provider.useValue);\n        }\n        emitProviderConfiguredEvent(provider);\n      });\n    }\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord.multi);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi.push(provider);\n    } else {\n      if (ngDevMode) {\n        const existing = this.records.get(token);\n        if (existing && existing.multi !== undefined) {\n          throwMixedMultiProviderError();\n        }\n      }\n    }\n    this.records.set(token, record);\n  }\n  hydrate(token, record, flags) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      if (record.value === CIRCULAR) {\n        throw cyclicDependencyError(stringify(token));\n      } else if (record.value === NOT_YET) {\n        record.value = CIRCULAR;\n        if (ngDevMode) {\n          runInInjectorProfilerContext(this, token, () => {\n            emitInjectorToCreateInstanceEvent(token);\n            record.value = record.factory(undefined, flags);\n            emitInstanceCreatedByInjectorEvent(record.value);\n          });\n        } else {\n          record.value = record.factory(undefined, flags);\n        }\n      }\n      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n        this._ngOnDestroyHooks.add(record.value);\n      }\n      return record.value;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  injectableDefInScope(def) {\n    if (!def.providedIn) {\n      return false;\n    }\n    const providedIn = resolveForwardRef(def.providedIn);\n    if (typeof providedIn === 'string') {\n      return providedIn === 'any' || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n  removeOnDestroy(callback) {\n    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n    if (destroyCBIdx !== -1) {\n      this._onDestroyHooks.splice(destroyCBIdx, 1);\n    }\n  }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n  if (factory !== null) {\n    return factory;\n  }\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n  }\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n  throw new RuntimeError(204, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);\n  }\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token);\n  } else {\n    return () => new token();\n  }\n}\nfunction providerToRecord(provider) {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory = providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\nfunction providerToFactory(provider, ngModuleType, providers) {\n  let factory = undefined;\n  if (ngDevMode && isEnvironmentProviders(provider)) {\n    throwInvalidProviderError(undefined, providers, provider);\n  }\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 ? 8 : undefined);\n    } else {\n      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\nfunction assertNotDestroyed(injector) {\n  if (injector.destroyed) {\n    throw new RuntimeError(205, ngDevMode && 'Injector has already been destroyed.');\n  }\n}\nfunction makeRecord(factory, value, multi = false) {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined\n  };\n}\nfunction hasDeps(value) {\n  return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n  return typeof value === 'function' || typeof value === 'object' && value.ngMetadataName === 'InjectionToken';\n}\nfunction forEachSingleProvider(providers, fn) {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (provider && isEnvironmentProviders(provider)) {\n      forEachSingleProvider(provider.ɵproviders, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nfunction runInInjectionContext(injector, fn) {\n  let internalInjector;\n  if (injector instanceof R3Injector) {\n    assertNotDestroyed(injector);\n    internalInjector = injector;\n  } else {\n    internalInjector = new RetrievingInjector(injector);\n  }\n  let prevInjectorProfilerContext;\n  if (ngDevMode) {\n    prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n  }\n  const prevInjector = setCurrentInjector(internalInjector);\n  const previousInjectImplementation = setInjectImplementation(undefined);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\nfunction isInInjectionContext() {\n  return getInjectImplementation() !== undefined || getCurrentInjector() != null;\n}\nfunction assertInInjectionContext(debugFn) {\n  if (!isInInjectionContext()) {\n    throw new RuntimeError(-203, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\n  }\n}\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst T_HOST = 5;\nconst HYDRATION = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst EFFECTS_TO_SCHEDULE = 22;\nconst EFFECTS = 23;\nconst REACTIVE_TEMPLATE_CONSUMER = 24;\nconst AFTER_RENDER_SEQUENCES_TO_ADD = 25;\nconst ANIMATIONS = 26;\nconst HEADER_OFFSET = 27;\nconst TYPE = 1;\nconst DEHYDRATED_VIEWS = 6;\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\nconst CONTAINER_HEADER_OFFSET = 10;\nfunction isLView(value) {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\nfunction isLContainer(value) {\n  return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n  return (tNode.flags & 4) !== 0;\n}\nfunction isComponentHost(tNode) {\n  return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n  return (tNode.flags & 1) === 1;\n}\nfunction isComponentDef(def) {\n  return !!def.template;\n}\nfunction isRootView(target) {\n  return (target[FLAGS] & 512) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n  return (tNode.type & 16) === 16;\n}\nfunction hasI18n(lView) {\n  return (lView[FLAGS] & 32) === 32;\n}\nfunction isDestroyed(lView) {\n  return (lView[FLAGS] & 256) === 256;\n}\nfunction assertTNodeForLView(tNode, lView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeCreationIndex(lView, index) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  assertIndexInRange(lView, adjustedIndex);\n  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');\n}\nfunction assertTNodeForTView(tNode, tView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\nfunction assertTIcu(tIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\nfunction assertComponentType(actual, msg = \"Type passed in is not ComponentType, it does not have 'ɵcmp' property.\") {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertNgModuleType(actual, msg = \"Type passed in is not NgModuleType, it does not have 'ɵmod' property.\") {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertHasParent(tNode) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n  assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');\n}\nfunction assertDirectiveDef(obj) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\nfunction assertIndexInDeclRange(tView, index) {\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n  assertDefined(lView, \"Component views should always have a parent view (component's host view)\");\n}\nfunction assertNodeInjector(lView, injectorIndex) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + 8);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');\n}\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\nfunction unwrapRNode(value) {\n  while (Array.isArray(value)) {\n    value = value[HOST];\n  }\n  return value;\n}\nfunction unwrapLView(value) {\n  while (Array.isArray(value)) {\n    if (typeof value[TYPE] === 'object') return value;\n    value = value[HOST];\n  }\n  return null;\n}\nfunction getNativeByIndex(index, lView) {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\nfunction getNativeByTNode(tNode, lView) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node = unwrapRNode(lView[tNode.index]);\n  return node;\n}\nfunction getNativeByTNodeOrNull(tNode, lView) {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node = unwrapRNode(lView[index]);\n    return node;\n  }\n  return null;\n}\nfunction getTNode(tView, index) {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index];\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\nfunction load(view, index) {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\nfunction store(tView, lView, index, value) {\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n  lView[index] = value;\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\nfunction isCreationMode(view) {\n  return (view[FLAGS] & 4) === 4;\n}\nfunction viewAttachedToChangeDetector(view) {\n  return (view[FLAGS] & 128) === 128;\n}\nfunction viewAttachedToContainer(view) {\n  return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts, index);\n  return consts[index];\n}\nfunction resetPreOrderHookFlags(lView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\nfunction markViewForRefresh(lView) {\n  if (lView[FLAGS] & 1024) {\n    return;\n  }\n  lView[FLAGS] |= 1024;\n  if (viewAttachedToChangeDetector(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\nfunction walkUpViews(nestingLevel, currentView) {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW];\n    nestingLevel--;\n  }\n  return currentView;\n}\nfunction requiresRefreshOrTraversal(lView) {\n  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);\n}\nfunction updateAncestorTraversalFlagsOnAttach(lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(8);\n  if (lView[FLAGS] & 64) {\n    lView[FLAGS] |= 1024;\n  }\n  if (requiresRefreshOrTraversal(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\nfunction markAncestorsForTraversal(lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(0);\n  let parent = getLViewParent(lView);\n  while (parent !== null) {\n    if (parent[FLAGS] & 8192) {\n      break;\n    }\n    parent[FLAGS] |= 8192;\n    if (!viewAttachedToChangeDetector(parent)) {\n      break;\n    }\n    parent = getLViewParent(parent);\n  }\n}\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n  if (isDestroyed(lView)) {\n    throw new RuntimeError(911, ngDevMode && 'View has already been destroyed.');\n  }\n  if (lView[ON_DESTROY_HOOKS] === null) {\n    lView[ON_DESTROY_HOOKS] = [];\n  }\n  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n  if (lView[ON_DESTROY_HOOKS] === null) return;\n  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n  if (destroyCBIdx !== -1) {\n    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n  }\n}\nfunction getLViewParent(lView) {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\nfunction getOrCreateLViewCleanup(view) {\n  return view[CLEANUP] ??= [];\n}\nfunction getOrCreateTViewCleanup(tView) {\n  return tView.cleanup ??= [];\n}\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n  lCleanup.push(context);\n  if (tView.firstCreatePass) {\n    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  } else {\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n  }\n}\nconst instructionState = {\n  lFrame: /*#__PURE__*/createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null\n};\nvar CheckNoChangesMode = /*#__PURE__*/function (CheckNoChangesMode) {\n  CheckNoChangesMode[CheckNoChangesMode[\"Off\"] = 0] = \"Off\";\n  CheckNoChangesMode[CheckNoChangesMode[\"Exhaustive\"] = 1] = \"Exhaustive\";\n  CheckNoChangesMode[CheckNoChangesMode[\"OnlyDirtyViews\"] = 2] = \"OnlyDirtyViews\";\n  return CheckNoChangesMode;\n}(CheckNoChangesMode || {});\nlet _checkNoChangesMode = 0;\nlet _isRefreshingViews = false;\nfunction getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n  return instructionState.bindingsEnabled;\n}\nfunction isInSkipHydrationBlock() {\n  return instructionState.skipHydrationRootTNode !== null;\n}\nfunction isSkipHydrationRootTNode(tNode) {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\nfunction ɵɵenableBindings() {\n  instructionState.bindingsEnabled = true;\n}\nfunction enterSkipHydrationBlock(tNode) {\n  instructionState.skipHydrationRootTNode = tNode;\n}\nfunction ɵɵdisableBindings() {\n  instructionState.bindingsEnabled = false;\n}\nfunction leaveSkipHydrationBlock() {\n  instructionState.skipHydrationRootTNode = null;\n}\nfunction getLView() {\n  return instructionState.lFrame.lView;\n}\nfunction getTView() {\n  return instructionState.lFrame.tView;\n}\nfunction ɵɵrestoreView(viewToRestore) {\n  instructionState.lFrame.contextLView = viewToRestore;\n  return viewToRestore[CONTEXT];\n}\nfunction ɵɵresetView(value) {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\nfunction getCurrentTNode() {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === 64) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n  return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n  return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n  instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\nfunction isExhaustiveCheckNoChanges() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _checkNoChangesMode = mode;\n}\nfunction isRefreshingViews() {\n  return _isRefreshingViews;\n}\nfunction setIsRefreshingViews(mode) {\n  const prev = _isRefreshingViews;\n  _isRefreshingViews = mode;\n  return prev;\n}\nfunction getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\nfunction getBindingIndex() {\n  return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n  return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n  return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\nfunction isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\nfunction getCurrentDirectiveIndex() {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\nfunction getCurrentDirectiveDef(tData) {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n  return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n  instructionState.lFrame.currentQueryIndex = value;\n}\nfunction getDeclarationTNode(lView) {\n  const tView = lView[TVIEW];\n  if (tView.type === 2) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n  if (tView.type === 1) {\n    return lView[T_HOST];\n  }\n  return null;\n}\nfunction enterDI(lView, tNode, flags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n  if (flags & 4) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n    let parentTNode = tNode;\n    let parentLView = lView;\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode.parent;\n      if (parentTNode === null && !(flags & 1)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW];\n        if (parentTNode.type & (2 | 8)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n  return true;\n}\nfunction enterView(newView) {\n  ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\nfunction createLFrame(parent) {\n  const lFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null,\n    tView: null,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent,\n    child: null,\n    inI18n: false\n  };\n  parent !== null && (parent.child = lFrame);\n  return lFrame;\n}\nfunction leaveViewLight() {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null;\n  oldLFrame.lView = null;\n  return oldLFrame;\n}\nconst leaveDI = leaveViewLight;\nfunction leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);\n  return contextLView[CONTEXT];\n}\nfunction getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\nfunction setSelectedIndex(index) {\n  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, \"Can't set index passed end of LView\");\n  instructionState.lFrame.selectedIndex = index;\n}\nfunction getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\nfunction ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\nfunction ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\nfunction ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\nfunction namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace() {\n  return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\nfunction wasLastNodeCreated() {\n  return _wasLastNodeCreated;\n}\nfunction lastNodeWasCreated(flag) {\n  _wasLastNodeCreated = flag;\n}\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\nclass Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL = /*#__PURE__*/new NullInjector();\n  static create(options, parent) {\n    if (Array.isArray(options)) {\n      return createInjector({\n        name: ''\n      }, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({\n        name\n      }, options.parent, options.providers, name);\n    }\n  }\n  static ɵprov = /* @__PURE__ */\n  ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR$1)\n  });\n  static __NG_ELEMENT_ID__ = -1;\n}\nconst DOCUMENT = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DocumentToken' : '');\nlet DestroyRef = /*#__PURE__*/(() => {\n  class DestroyRef {\n    static __NG_ELEMENT_ID__ = injectDestroyRef;\n    static __NG_ENV_ID__ = injector => injector;\n  }\n  return DestroyRef;\n})();\nclass NodeInjectorDestroyRef extends DestroyRef {\n  _lView;\n  constructor(_lView) {\n    super();\n    this._lView = _lView;\n  }\n  get destroyed() {\n    return isDestroyed(this._lView);\n  }\n  onDestroy(callback) {\n    const lView = this._lView;\n    storeLViewOnDestroy(lView, callback);\n    return () => removeLViewOnDestroy(lView, callback);\n  }\n}\nfunction injectDestroyRef() {\n  return new NodeInjectorDestroyRef(getLView());\n}\nconst SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;\nlet PendingTasksInternal = /*#__PURE__*/(() => {\n  class PendingTasksInternal {\n    taskId = 0;\n    pendingTasks = new Set();\n    destroyed = false;\n    pendingTask = new BehaviorSubject(false);\n    get hasPendingTasks() {\n      return this.destroyed ? false : this.pendingTask.value;\n    }\n    get hasPendingTasksObservable() {\n      if (this.destroyed) {\n        return new Observable(subscriber => {\n          subscriber.next(false);\n          subscriber.complete();\n        });\n      }\n      return this.pendingTask;\n    }\n    add() {\n      if (!this.hasPendingTasks && !this.destroyed) {\n        this.pendingTask.next(true);\n      }\n      const taskId = this.taskId++;\n      this.pendingTasks.add(taskId);\n      return taskId;\n    }\n    has(taskId) {\n      return this.pendingTasks.has(taskId);\n    }\n    remove(taskId) {\n      this.pendingTasks.delete(taskId);\n      if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\n        this.pendingTask.next(false);\n      }\n    }\n    ngOnDestroy() {\n      this.pendingTasks.clear();\n      if (this.hasPendingTasks) {\n        this.pendingTask.next(false);\n      }\n      this.destroyed = true;\n      this.pendingTask.unsubscribe();\n    }\n    static ɵprov = /* @__PURE__ */\n    ɵɵdefineInjectable({\n      token: PendingTasksInternal,\n      providedIn: 'root',\n      factory: () => new PendingTasksInternal()\n    });\n  }\n  return PendingTasksInternal;\n})();\nclass EventEmitter_ extends Subject {\n  __isAsync;\n  destroyRef = undefined;\n  pendingTasks = undefined;\n  constructor(isAsync = false) {\n    super();\n    this.__isAsync = isAsync;\n    if (isInInjectionContext()) {\n      this.destroyRef = inject(DestroyRef, {\n        optional: true\n      }) ?? undefined;\n      this.pendingTasks = inject(PendingTasksInternal, {\n        optional: true\n      }) ?? undefined;\n    }\n  }\n  emit(value) {\n    const prevConsumer = setActiveConsumer$1(null);\n    try {\n      super.next(value);\n    } finally {\n      setActiveConsumer$1(prevConsumer);\n    }\n  }\n  subscribe(observerOrNext, error, complete) {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n    if (this.__isAsync) {\n      errorFn = this.wrapInTimeout(errorFn);\n      if (nextFn) {\n        nextFn = this.wrapInTimeout(nextFn);\n      }\n      if (completeFn) {\n        completeFn = this.wrapInTimeout(completeFn);\n      }\n    }\n    const sink = super.subscribe({\n      next: nextFn,\n      error: errorFn,\n      complete: completeFn\n    });\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n    return sink;\n  }\n  wrapInTimeout(fn) {\n    return value => {\n      const taskId = this.pendingTasks?.add();\n      setTimeout(() => {\n        try {\n          fn(value);\n        } finally {\n          if (taskId !== undefined) {\n            this.pendingTasks?.remove(taskId);\n          }\n        }\n      });\n    };\n  }\n}\nconst EventEmitter = EventEmitter_;\nfunction noop(...args) {}\nfunction scheduleCallbackWithRafRace(callback) {\n  let timeoutId;\n  let animationFrameId;\n  function cleanup() {\n    callback = noop;\n    try {\n      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {\n        cancelAnimationFrame(animationFrameId);\n      }\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    } catch {}\n  }\n  timeoutId = setTimeout(() => {\n    callback();\n    cleanup();\n  });\n  if (typeof requestAnimationFrame === 'function') {\n    animationFrameId = requestAnimationFrame(() => {\n      callback();\n      cleanup();\n    });\n  }\n  return () => cleanup();\n}\nfunction scheduleCallbackWithMicrotask(callback) {\n  queueMicrotask(() => callback());\n  return () => {\n    callback = noop;\n  };\n}\nclass AsyncStackTaggingZoneSpec {\n  createTask;\n  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {\n    this.name = 'asyncStackTagging for ' + namePrefix;\n    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);\n  }\n  name;\n  onScheduleTask(delegate, _current, target, task) {\n    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);\n    return delegate.scheduleTask(target, task);\n  }\n  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {\n    let ret;\n    if (task.consoleTask) {\n      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));\n    } else {\n      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n    return ret;\n  }\n}\nconst isAngularZoneProperty = 'isAngularZone';\nconst angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';\nlet ngZoneInstanceId = 0;\nclass NgZone {\n  hasPendingMacrotasks = false;\n  hasPendingMicrotasks = false;\n  isStable = true;\n  onUnstable = /*#__PURE__*/new EventEmitter(false);\n  onMicrotaskEmpty = /*#__PURE__*/new EventEmitter(false);\n  onStable = /*#__PURE__*/new EventEmitter(false);\n  onError = /*#__PURE__*/new EventEmitter(false);\n  constructor(options) {\n    const {\n      enableLongStackTrace = false,\n      shouldCoalesceEventChangeDetection = false,\n      shouldCoalesceRunChangeDetection = false,\n      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT\n    } = options;\n    if (typeof Zone == 'undefined') {\n      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);\n    }\n    Zone.assertZonePatched();\n    const self = this;\n    self._nesting = 0;\n    self._outer = self._inner = Zone.current;\n    if (ngDevMode) {\n      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));\n    }\n    if (Zone['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());\n    }\n    if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);\n    }\n    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.callbackScheduled = false;\n    self.scheduleInRootZone = scheduleInRootZone;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n  static isInAngularZone() {\n    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;\n  }\n  static assertInAngularZone() {\n    if (!NgZone.isInAngularZone()) {\n      throw new RuntimeError(909, ngDevMode && 'Expected to be in Angular Zone, but it is not!');\n    }\n  }\n  static assertNotInAngularZone() {\n    if (NgZone.isInAngularZone()) {\n      throw new RuntimeError(909, ngDevMode && 'Expected to not be in Angular Zone, but it is!');\n    }\n  }\n  run(fn, applyThis, applyArgs) {\n    return this._inner.run(fn, applyThis, applyArgs);\n  }\n  runTask(fn, applyThis, applyArgs, name) {\n    const zone = this._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n  runGuarded(fn, applyThis, applyArgs) {\n    return this._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n  runOutsideAngular(fn) {\n    return this._outer.run(fn);\n  }\n}\nconst EMPTY_PAYLOAD = {};\nfunction checkStable(zone) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\nfunction delayChangeDetectionForEvents(zone) {\n  if (zone.isCheckStableRunning || zone.callbackScheduled) {\n    return;\n  }\n  zone.callbackScheduled = true;\n  function scheduleCheckStable() {\n    scheduleCallbackWithRafRace(() => {\n      zone.callbackScheduled = false;\n      updateMicroTaskStatus(zone);\n      zone.isCheckStableRunning = true;\n      checkStable(zone);\n      zone.isCheckStableRunning = false;\n    });\n  }\n  if (zone.scheduleInRootZone) {\n    Zone.root.run(() => {\n      scheduleCheckStable();\n    });\n  } else {\n    zone._outer.run(() => {\n      scheduleCheckStable();\n    });\n  }\n  updateMicroTaskStatus(zone);\n}\nfunction forkInnerZoneWithAngularBehavior(zone) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  const instanceId = ngZoneInstanceId++;\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: {\n      [isAngularZoneProperty]: true,\n      [angularZoneInstanceIdProperty]: instanceId,\n      [angularZoneInstanceIdProperty + instanceId]: true\n    },\n    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {\n      if (shouldBeIgnoredByZone(applyArgs)) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (zone.shouldCoalesceRunChangeDetection && !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onHasTask: (delegate, current, target, hasTaskState) => {\n      delegate.hasTask(target, hasTaskState);\n      if (current === target) {\n        if (hasTaskState.change == 'microTask') {\n          zone._hasPendingMicrotasks = hasTaskState.microTask;\n          updateMicroTaskStatus(zone);\n          checkStable(zone);\n        } else if (hasTaskState.change == 'macroTask') {\n          zone.hasPendingMacrotasks = hasTaskState.macroTask;\n        }\n      }\n    },\n    onHandleError: (delegate, current, target, error) => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\nfunction updateMicroTaskStatus(zone) {\n  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\nfunction onEnter(zone) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\nfunction onLeave(zone) {\n  zone._nesting--;\n  checkStable(zone);\n}\nclass NoopNgZone {\n  hasPendingMicrotasks = false;\n  hasPendingMacrotasks = false;\n  isStable = true;\n  onUnstable = /*#__PURE__*/new EventEmitter();\n  onMicrotaskEmpty = /*#__PURE__*/new EventEmitter();\n  onStable = /*#__PURE__*/new EventEmitter();\n  onError = /*#__PURE__*/new EventEmitter();\n  run(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runGuarded(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runOutsideAngular(fn) {\n    return fn();\n  }\n  runTask(fn, applyThis, applyArgs, name) {\n    return fn.apply(applyThis, applyArgs);\n  }\n}\nfunction shouldBeIgnoredByZone(applyArgs) {\n  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');\n}\nfunction isSchedulerTick(applyArgs) {\n  return hasApplyArgsData(applyArgs, '__scheduler_tick__');\n}\nfunction hasApplyArgsData(applyArgs, key) {\n  if (!Array.isArray(applyArgs)) {\n    return false;\n  }\n  if (applyArgs.length !== 1) {\n    return false;\n  }\n  return applyArgs[0]?.data?.[key] === true;\n}\nclass ErrorHandler {\n  _console = console;\n  handleError(error) {\n    this._console.error('ERROR', error);\n  }\n}\nconst INTERNAL_APPLICATION_ERROR_HANDLER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {\n  factory: () => {\n    const zone = inject(NgZone);\n    const injector = inject(EnvironmentInjector);\n    let userErrorHandler;\n    return e => {\n      zone.runOutsideAngular(() => {\n        if (injector.destroyed && !userErrorHandler) {\n          setTimeout(() => {\n            throw e;\n          });\n        } else {\n          userErrorHandler ??= injector.get(ErrorHandler);\n          userErrorHandler.handleError(e);\n        }\n      });\n    };\n  }\n});\nconst errorHandlerEnvironmentInitializer = {\n  provide: ENVIRONMENT_INITIALIZER,\n  useValue: () => {\n    const handler = inject(ErrorHandler, {\n      optional: true\n    });\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && handler === null) {\n      throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');\n    }\n  },\n  multi: true\n};\nconst globalErrorListeners = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'GlobalErrorListeners' : '', {\n  factory: () => {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return;\n    }\n    const window = inject(DOCUMENT).defaultView;\n    if (!window) {\n      return;\n    }\n    const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n    const rejectionListener = e => {\n      errorHandler(e.reason);\n      e.preventDefault();\n    };\n    const errorListener = e => {\n      if (e.error) {\n        errorHandler(e.error);\n      } else {\n        errorHandler(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}` : e.message, {\n          cause: e\n        }));\n      }\n      e.preventDefault();\n    };\n    const setupEventListeners = () => {\n      window.addEventListener('unhandledrejection', rejectionListener);\n      window.addEventListener('error', errorListener);\n    };\n    if (typeof Zone !== 'undefined') {\n      Zone.root.run(setupEventListeners);\n    } else {\n      setupEventListeners();\n    }\n    inject(DestroyRef).onDestroy(() => {\n      window.removeEventListener('error', errorListener);\n      window.removeEventListener('unhandledrejection', rejectionListener);\n    });\n  }\n});\nfunction provideBrowserGlobalErrorListeners() {\n  return makeEnvironmentProviders([provideEnvironmentInitializer(() => void inject(globalErrorListeners))]);\n}\nfunction ɵunwrapWritableSignal(value) {\n  return null;\n}\nfunction signal(initialValue, options) {\n  const [get, set, update] = createSignal(initialValue, options?.equal);\n  const signalFn = get;\n  const node = signalFn[SIGNAL];\n  signalFn.set = set;\n  signalFn.update = update;\n  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);\n  if (ngDevMode) {\n    signalFn.toString = () => `[Signal: ${signalFn()}]`;\n    node.debugName = options?.debugName;\n  }\n  return signalFn;\n}\nfunction signalAsReadonlyFn() {\n  const node = this[SIGNAL];\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    readonlyFn[SIGNAL] = node;\n    node.readonlyFn = readonlyFn;\n  }\n  return node.readonlyFn;\n}\nfunction assertNotInReactiveContext(debugFn, extraContext) {\n  if (getActiveConsumer() !== null) {\n    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);\n  }\n}\nlet ViewContext = /*#__PURE__*/(() => {\n  class ViewContext {\n    view;\n    node;\n    constructor(view, node) {\n      this.view = view;\n      this.node = node;\n    }\n    static __NG_ELEMENT_ID__ = injectViewContext;\n  }\n  return ViewContext;\n})();\nfunction injectViewContext() {\n  return new ViewContext(getLView(), getCurrentTNode());\n}\nclass ChangeDetectionScheduler {}\nconst ZONELESS_ENABLED = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', {\n  factory: () => true\n});\nconst PROVIDED_ZONELESS = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', {\n  factory: () => false\n});\nconst SCHEDULE_IN_ROOT_ZONE = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');\nlet PendingTasks = /*#__PURE__*/(() => {\n  class PendingTasks {\n    internalPendingTasks = inject(PendingTasksInternal);\n    scheduler = inject(ChangeDetectionScheduler);\n    errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n    add() {\n      const taskId = this.internalPendingTasks.add();\n      return () => {\n        if (!this.internalPendingTasks.has(taskId)) {\n          return;\n        }\n        this.scheduler.notify(11);\n        this.internalPendingTasks.remove(taskId);\n      };\n    }\n    run(fn) {\n      const removeTask = this.add();\n      fn().catch(this.errorHandler).finally(removeTask);\n    }\n    static ɵprov = /* @__PURE__ */\n    ɵɵdefineInjectable({\n      token: PendingTasks,\n      providedIn: 'root',\n      factory: () => new PendingTasks()\n    });\n  }\n  return PendingTasks;\n})();\nlet EffectScheduler = /*#__PURE__*/(() => {\n  class EffectScheduler {\n    static ɵprov = /* @__PURE__ */\n    ɵɵdefineInjectable({\n      token: EffectScheduler,\n      providedIn: 'root',\n      factory: () => new ZoneAwareEffectScheduler()\n    });\n  }\n  return EffectScheduler;\n})();\nclass ZoneAwareEffectScheduler {\n  dirtyEffectCount = 0;\n  queues = /*#__PURE__*/new Map();\n  add(handle) {\n    this.enqueue(handle);\n    this.schedule(handle);\n  }\n  schedule(handle) {\n    if (!handle.dirty) {\n      return;\n    }\n    this.dirtyEffectCount++;\n  }\n  remove(handle) {\n    const zone = handle.zone;\n    const queue = this.queues.get(zone);\n    if (!queue.has(handle)) {\n      return;\n    }\n    queue.delete(handle);\n    if (handle.dirty) {\n      this.dirtyEffectCount--;\n    }\n  }\n  enqueue(handle) {\n    const zone = handle.zone;\n    if (!this.queues.has(zone)) {\n      this.queues.set(zone, new Set());\n    }\n    const queue = this.queues.get(zone);\n    if (queue.has(handle)) {\n      return;\n    }\n    queue.add(handle);\n  }\n  flush() {\n    while (this.dirtyEffectCount > 0) {\n      let ranOneEffect = false;\n      for (const [zone, queue] of this.queues) {\n        if (zone === null) {\n          ranOneEffect ||= this.flushQueue(queue);\n        } else {\n          ranOneEffect ||= zone.run(() => this.flushQueue(queue));\n        }\n      }\n      if (!ranOneEffect) {\n        this.dirtyEffectCount = 0;\n      }\n    }\n  }\n  flushQueue(queue) {\n    let ranOneEffect = false;\n    for (const handle of queue) {\n      if (!handle.dirty) {\n        continue;\n      }\n      this.dirtyEffectCount--;\n      ranOneEffect = true;\n      handle.run();\n    }\n    return ranOneEffect;\n  }\n}\nclass EffectRefImpl {\n  [SIGNAL];\n  constructor(node) {\n    this[SIGNAL] = node;\n  }\n  destroy() {\n    this[SIGNAL].destroy();\n  }\n}\nfunction effect(effectFn, options) {\n  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(effect);\n  }\n  if (ngDevMode && options?.allowSignalWrites !== undefined) {\n    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  let node;\n  const viewContext = injector.get(ViewContext, null, {\n    optional: true\n  });\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null) {\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      destroyRef = null;\n    }\n  } else {\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n  if (destroyRef !== null) {\n    node.onDestroyFns = [destroyRef.onDestroy(() => node.destroy())];\n  }\n  const effectRef = new EffectRefImpl(node);\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? '';\n    const prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n  return effectRef;\n}\nconst EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...BASE_EFFECT_NODE,\n  cleanupFns: undefined,\n  zone: null,\n  onDestroyFns: null,\n  run() {\n    if (ngDevMode && isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    const prevRefreshingViews = setIsRefreshingViews(false);\n    try {\n      runEffect(this);\n    } finally {\n      setIsRefreshingViews(prevRefreshingViews);\n    }\n  },\n  cleanup() {\n    if (!this.cleanupFns?.length) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer$1(null);\n    try {\n      while (this.cleanupFns.length) {\n        this.cleanupFns.pop()();\n      }\n    } finally {\n      this.cleanupFns = [];\n      setActiveConsumer$1(prevConsumer);\n    }\n  }\n}))();\nconst ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.scheduler.schedule(this);\n    this.notifier.notify(12);\n  },\n  destroy() {\n    consumerDestroy(this);\n    if (this.onDestroyFns !== null) {\n      for (const fn of this.onDestroyFns) {\n        fn();\n      }\n    }\n    this.cleanup();\n    this.scheduler.remove(this);\n  }\n}))();\nconst VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.view[FLAGS] |= 8192;\n    markAncestorsForTraversal(this.view);\n    this.notifier.notify(13);\n  },\n  destroy() {\n    consumerDestroy(this);\n    if (this.onDestroyFns !== null) {\n      for (const fn of this.onDestroyFns) {\n        fn();\n      }\n    }\n    this.cleanup();\n    this.view[EFFECTS]?.delete(this);\n  }\n}))();\nfunction createViewEffect(view, notifier, fn) {\n  const node = Object.create(VIEW_EFFECT_NODE);\n  node.view = view;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = createEffectFn(node, fn);\n  view[EFFECTS] ??= new Set();\n  view[EFFECTS].add(node);\n  node.consumerMarkedDirty(node);\n  return node;\n}\nfunction createRootEffect(fn, scheduler, notifier) {\n  const node = Object.create(ROOT_EFFECT_NODE);\n  node.fn = createEffectFn(node, fn);\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.scheduler.add(node);\n  node.notifier.notify(12);\n  return node;\n}\nfunction createEffectFn(node, fn) {\n  return () => {\n    fn(cleanupFn => (node.cleanupFns ??= []).push(cleanupFn));\n  };\n}\nfunction untracked(nonReactiveReadsFn) {\n  return untracked$1(nonReactiveReadsFn);\n}\nexport { AFTER_RENDER_SEQUENCES_TO_ADD, ANIMATIONS, CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTAINER_HEADER_OFFSET, CONTEXT, ChangeDetectionScheduler, CheckNoChangesMode, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DECLARATION_VIEW, DEHYDRATED_VIEWS, DOCUMENT, DestroyRef, EFFECTS, EFFECTS_TO_SCHEDULE, EMBEDDED_VIEW_INJECTOR, EMPTY_ARRAY, EMPTY_OBJ, ENVIRONMENT, ENVIRONMENT_INITIALIZER, EffectRefImpl, EffectScheduler, EnvironmentInjector, ErrorHandler, EventEmitter, FLAGS, HEADER_OFFSET, HOST, HYDRATION, ID, INJECTOR$1 as INJECTOR, INJECTOR as INJECTOR$1, INJECTOR_DEF_TYPES, INJECTOR_SCOPE, INTERNAL_APPLICATION_ERROR_HANDLER, InjectionToken, Injector, MATH_ML_NAMESPACE, MOVED_VIEWS, NATIVE, NEXT, NG_COMP_DEF, NG_DIR_DEF, NG_ELEMENT_ID, NG_FACTORY_DEF, NG_INJ_DEF, NG_MOD_DEF, NG_PIPE_DEF, NG_PROV_DEF, NgZone, NoopNgZone, NullInjector, ON_DESTROY_HOOKS, PARENT, PREORDER_HOOK_FLAGS, PROVIDED_ZONELESS, PendingTasks, PendingTasksInternal, QUERIES, R3Injector, REACTIVE_TEMPLATE_CONSUMER, RENDERER, RuntimeError, SCHEDULE_IN_ROOT_ZONE, SCHEDULE_IN_ROOT_ZONE_DEFAULT, SVG_NAMESPACE, TVIEW, T_HOST, VERSION, VIEW_REFS, Version, ViewContext, XSS_SECURITY_URL, ZONELESS_ENABLED, _global, addToArray, angularZoneInstanceIdProperty, arrayEquals, arrayInsert2, arraySplice, assertComponentType, assertDefined, assertDirectiveDef, assertDomNode, assertElement, assertEqual, assertFirstCreatePass, assertFirstUpdatePass, assertFunction, assertGreaterThan, assertGreaterThanOrEqual, assertHasParent, assertInInjectionContext, assertIndexInDeclRange, assertIndexInExpandoRange, assertIndexInRange, assertInjectImplementationNotEqual, assertLContainer, assertLView, assertLessThan, assertNgModuleType, assertNodeInjector, assertNotDefined, assertNotEqual, assertNotInReactiveContext, assertNotReactive, assertNotSame, assertNumber, assertNumberInRange, assertOneOf, assertParentView, assertProjectionSlots, assertSame, assertString, assertTIcu, assertTNode, assertTNodeCreationIndex, assertTNodeForLView, assertTNodeForTView, attachInjectFlag, concatStringsWithSpace, convertToBitFlags, createInjector, createInjectorWithoutInjectorInstances, cyclicDependencyError, cyclicDependencyErrorWithDetails, debugStringifyTypeForError, decreaseElementDepthCount, deepForEach, effect, emitAfterRenderEffectPhaseCreatedEvent, emitInjectEvent, emitInjectorToCreateInstanceEvent, emitInstanceCreatedByInjectorEvent, emitProviderConfiguredEvent, enterDI, enterSkipHydrationBlock, enterView, errorHandlerEnvironmentInitializer, fillProperties, flatten, formatRuntimeError, forwardRef, getBindingIndex, getBindingRoot, getBindingsEnabled, getClosureSafeProperty, getComponentDef, getComponentLViewByIndex, getConstant, getContextLView, getCurrentDirectiveDef, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentQueryIndex, getCurrentTNode, getCurrentTNodePlaceholderOk, getDirectiveDef, getDirectiveDefOrThrow, getElementDepthCount, getFactoryDef, getInjectableDef, getInjectorDef, getLView, getLViewParent, getNamespace, getNativeByIndex, getNativeByTNode, getNativeByTNodeOrNull, getNgModuleDef, getNgModuleDefOrThrow, getNullInjector, getOrCreateLViewCleanup, getOrCreateTViewCleanup, getPipeDef, getSelectedIndex, getSelectedTNode, getTNode, getTView, hasI18n, importProvidersFrom, increaseElementDepthCount, incrementBindingIndex, initNgDevMode, inject, injectRootLimpMode, internalImportProvidersFrom, isClassProvider, isComponentDef, isComponentHost, isContentQueryHost, isCreationMode, isCurrentTNodeParent, isDestroyed, isDirectiveHost, isEnvironmentProviders, isExhaustiveCheckNoChanges, isForwardRef, isInCheckNoChangesMode, isInI18nBlock, isInInjectionContext, isInSkipHydrationBlock, isInjectable, isLContainer, isLView, isProjectionTNode, isRefreshingViews, isRootView, isSkipHydrationRootTNode, isStandalone, isTypeProvider, keyValueArrayGet, keyValueArrayIndexOf, keyValueArraySet, lastNodeWasCreated, leaveDI, leaveSkipHydrationBlock, leaveView, load, makeEnvironmentProviders, markAncestorsForTraversal, markViewForRefresh, newArray, nextBindingIndex, nextContextImpl, provideBrowserGlobalErrorListeners, provideEnvironmentInitializer, providerToFactory, removeFromArray, removeLViewOnDestroy, renderStringify, requiresRefreshOrTraversal, resetPreOrderHookFlags, resolveForwardRef, runInInjectionContext, runInInjectorProfilerContext, scheduleCallbackWithMicrotask, scheduleCallbackWithRafRace, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setCurrentTNodeAsNotParent, setInI18nBlock, setInjectImplementation, setInjectorProfiler, setInjectorProfilerContext, setIsInCheckNoChangesMode, setIsRefreshingViews, setSelectedIndex, signal, signalAsReadonlyFn, store, storeCleanupWithContext, storeLViewOnDestroy, stringify, stringifyForError, throwError, throwProviderNotFoundError, truncateMiddle, untracked, unwrapLView, unwrapRNode, updateAncestorTraversalFlagsOnAttach, viewAttachedToChangeDetector, viewAttachedToContainer, walkProviderTree, walkUpViews, wasLastNodeCreated, ɵunwrapWritableSignal, ɵɵdefineInjectable, ɵɵdefineInjector, ɵɵdisableBindings, ɵɵenableBindings, ɵɵinject, ɵɵinvalidFactoryDep, ɵɵnamespaceHTML, ɵɵnamespaceMathML, ɵɵnamespaceSVG, ɵɵresetView, ɵɵrestoreView };","map":{"version":3,"names":["getActiveConsumer","setActiveConsumer","setActiveConsumer$1","createSignal","SIGNAL","consumerDestroy","BASE_EFFECT_NODE","isInNotificationPhase","runEffect","untracked","untracked$1","BehaviorSubject","Observable","Subject","Subscription","isNotFound","getCurrentInjector","setCurrentInjector","isNotFound$1","Version","full","major","minor","patch","constructor","parts","split","slice","join","VERSION","ERROR_DETAILS_PAGE_BASE_URL","versionSubDomain","XSS_SECURITY_URL","RuntimeError","Error","code","message","formatRuntimeError","formatRuntimeErrorCode","Math","abs","fullCode","errorMessage","ngDevMode","addPeriodSeparator","match","separator","_global","globalThis","ngDevModeResetPerfCounters","locationString","location","toString","newCounters","hydratedNodes","hydratedComponents","dehydratedViewsRemoved","dehydratedViewsCleanupRuns","componentsSkippedHydration","deferBlocksWithIncrementalHydration","allowNgDevModeTrue","indexOf","Object","assign","initNgDevMode","keys","length","getClosureSafeProperty","objWithPropertyToExtract","key","fillProperties","target","source","hasOwnProperty","stringify","token","Array","isArray","map","name","overriddenName","result","newLineIndex","concatStringsWithSpace","before","after","truncateMiddle","str","maxLength","substring","halfLimit","round","__forward_ref__","forwardRef","forwardRefFn","resolveForwardRef","type","isForwardRef","fn","assertNumber","actual","msg","throwError","assertNumberInRange","minInclusive","maxInclusive","assertLessThanOrEqual","assertGreaterThanOrEqual","assertString","assertFunction","assertEqual","expected","assertNotEqual","assertSame","assertNotSame","assertLessThan","assertGreaterThan","assertNotDefined","assertDefined","comparison","assertDomNode","node","Node","assertElement","Element","assertIndexInRange","arr","index","maxLen","assertOneOf","value","validValues","JSON","assertNotReactive","ɵɵdefineInjectable","opts","providedIn","factory","undefined","ɵɵdefineInjector","options","providers","imports","getInjectableDef","getOwnDefinition","NG_PROV_DEF","isInjectable","field","getInheritedInjectableDef","def","console","warn","getInjectorDef","NG_INJ_DEF","ɵprov","ɵinj","InjectionToken","_desc","ngMetadataName","__NG_ELEMENT_ID__","multi","_injectorProfilerContext","getInjectorProfilerContext","setInjectorProfilerContext","context","previous","injectorProfilerCallbacks","NOOP_PROFILER_REMOVAL","removeProfiler","profiler","profilerIdx","splice","setInjectorProfiler","injectorProfiler","includes","push","event","i","injectorProfilerCallback","emitProviderConfiguredEvent","eventProvider","isViewProvider","provide","provider","providerRecord","emitInjectorToCreateInstanceEvent","emitInstanceCreatedByInjectorEvent","instance","emitInjectEvent","flags","service","emitEffectCreatedEvent","effect","emitAfterRenderEffectPhaseCreatedEvent","effectPhase","runInInjectorProfilerContext","injector","callback","prevInjectContext","isEnvironmentProviders","ɵproviders","NG_COMP_DEF","ɵcmp","NG_DIR_DEF","ɵdir","NG_PIPE_DEF","ɵpipe","NG_MOD_DEF","ɵmod","NG_FACTORY_DEF","ɵfac","NG_ELEMENT_ID","NG_ENV_ID","__NG_ENV_ID__","getNgModuleDef","assertTypeDefined","getNgModuleDefOrThrow","ngModuleDef","getComponentDef","getDirectiveDefOrThrow","getDirectiveDef","getPipeDef","symbolType","isStandalone","standalone","renderStringify","String","stringifyForError","debugStringifyTypeForError","componentDef","debugInfo","stringifyTypeFromDebugInfo","filePath","lineNumber","className","NG_RUNTIME_ERROR_CODE","NG_RUNTIME_ERROR_MESSAGE","NG_TOKEN_PATH","cyclicDependencyError","path","createRuntimeError","cyclicDependencyErrorWithDetails","augmentRuntimeError","throwMixedMultiProviderError","throwInvalidProviderError","ngModuleType","providerDetail","v","ɵfromNgModule","throwProviderNotFoundError","injectorName","prependTokenToDependencyPath","error","currentPath","pathStr","unshift","tokenPath","errorCode","formatErrorMessage","getRuntimeErrorCode","text","pathDetails","sourceDetails","_injectImplementation","getInjectImplementation","setInjectImplementation","impl","injectRootLimpMode","notFoundValue","injectableDef","assertInjectImplementationNotEqual","_THROW_IF_NOT_FOUND","THROW_IF_NOT_FOUND","DI_DECORATOR_FLAG","RetrievingInjector","retrieve","convertToBitFlags","get","e","injectInjectorOnly","currentInjector","convertToInjectOptions","optional","ɵɵinject","ɵɵinvalidFactoryDep","inject","host","self","skipSelf","injectArgs","types","args","arg","j","meta","flag","getInjectFlag","attachInjectFlag","decorator","prototype","getFactoryDef","throwNotFound","hasFactoryDef","arrayEquals","a","b","identityAccessor","valueA","valueB","flatten","list","flat","Number","POSITIVE_INFINITY","deepForEach","input","forEach","addToArray","removeFromArray","pop","newArray","size","arraySplice","array","count","arrayInsert2","value1","value2","end","previousEnd","keyValueArraySet","keyValueArray","keyValueArrayIndexOf","keyValueArrayGet","_arrayIndexOfSorted","shift","start","middle","current","EMPTY_OBJ","EMPTY_ARRAY","freeze","ENVIRONMENT_INITIALIZER","INJECTOR$1","INJECTOR_DEF_TYPES","NullInjector","makeEnvironmentProviders","provideEnvironmentInitializer","initializerFn","useValue","importProvidersFrom","sources","internalImportProvidersFrom","checkForStandaloneCmp","providersOut","dedup","Set","injectorTypesWithProviders","collectProviders","cmpDef","internalSource","walkProviderTree","processInjectorTypesWithProviders","typesWithProviders","visitor","ngModule","deepForEachProvider","validateProvider","container","parents","defType","injDef","defName","concat","isDuplicate","has","add","dependencies","deps","dep","importTypesWithProviders","imported","useFactory","defProviders","injectorType","containerType","isTypeProvider","isValueProvider","isFactoryProvider","isExistingProvider","classRef","useClass","USE_VALUE","useExisting","isClassProvider","INJECTOR_SCOPE","NOT_YET","CIRCULAR","NULL_INJECTOR","getNullInjector","EnvironmentInjector","R3Injector","parent","scopes","records","Map","_ngOnDestroyHooks","_onDestroyHooks","destroyed","_destroyed","injectorDefTypes","forEachSingleProvider","processProvider","set","makeRecord","record","destroy","assertNotDestroyed","prevConsumer","ngOnDestroy","onDestroyHooks","hook","clear","onDestroy","removeOnDestroy","runInContext","previousInjector","previousInjectImplementation","couldBeInjectableType","injectableDefInScope","injectableDefOrInjectorDefFactory","hydrate","nextInjector","resolveInjectorInitializers","initializers","initializer","tokens","providerToRecord","multiRecord","existing","hasOnDestroy","destroyCBIdx","Function","getUndecoratedInjectableFactory","paramLength","inheritedInjectableDef","providerToFactory","unwrappedProvider","_","hasDeps","runInInjectionContext","internalInjector","prevInjectorProfilerContext","prevInjector","isInInjectionContext","assertInInjectionContext","debugFn","HOST","TVIEW","FLAGS","PARENT","NEXT","T_HOST","HYDRATION","CLEANUP","CONTEXT","INJECTOR","ENVIRONMENT","RENDERER","CHILD_HEAD","CHILD_TAIL","DECLARATION_VIEW","DECLARATION_COMPONENT_VIEW","DECLARATION_LCONTAINER","PREORDER_HOOK_FLAGS","QUERIES","ID","EMBEDDED_VIEW_INJECTOR","ON_DESTROY_HOOKS","EFFECTS_TO_SCHEDULE","EFFECTS","REACTIVE_TEMPLATE_CONSUMER","AFTER_RENDER_SEQUENCES_TO_ADD","ANIMATIONS","HEADER_OFFSET","TYPE","DEHYDRATED_VIEWS","NATIVE","VIEW_REFS","MOVED_VIEWS","CONTAINER_HEADER_OFFSET","isLView","isLContainer","isContentQueryHost","tNode","isComponentHost","componentOffset","isDirectiveHost","isComponentDef","template","isRootView","isProjectionTNode","hasI18n","lView","isDestroyed","assertTNodeForLView","assertTNodeForTView","assertTNodeCreationIndex","adjustedIndex","bindingStartIndex","tView","assertTNode","tData","data","assertTIcu","tIcu","currentCaseLViewIndex","assertComponentType","assertNgModuleType","assertHasParent","assertLContainer","assertLViewOrUndefined","assertLView","assertFirstCreatePass","errMessage","firstCreatePass","assertFirstUpdatePass","firstUpdatePass","assertDirectiveDef","obj","selectors","inputs","assertIndexInDeclRange","assertBetween","assertIndexInExpandoRange","expandoStartIndex","lower","upper","assertProjectionSlots","projection","assertParentView","assertNodeInjector","injectorIndex","SVG_NAMESPACE","MATH_ML_NAMESPACE","unwrapRNode","unwrapLView","getNativeByIndex","getNativeByTNode","getNativeByTNodeOrNull","getTNode","load","view","store","blueprint","getComponentLViewByIndex","nodeIndex","hostView","slotValue","isCreationMode","viewAttachedToChangeDetector","viewAttachedToContainer","getConstant","consts","resetPreOrderHookFlags","markViewForRefresh","markAncestorsForTraversal","walkUpViews","nestingLevel","currentView","requiresRefreshOrTraversal","dirty","updateAncestorTraversalFlagsOnAttach","changeDetectionScheduler","notify","getLViewParent","storeLViewOnDestroy","onDestroyCallback","removeLViewOnDestroy","getOrCreateLViewCleanup","getOrCreateTViewCleanup","cleanup","storeCleanupWithContext","cleanupFn","lCleanup","instructionState","lFrame","createLFrame","bindingsEnabled","skipHydrationRootTNode","CheckNoChangesMode","_checkNoChangesMode","_isRefreshingViews","getElementDepthCount","elementDepthCount","increaseElementDepthCount","decreaseElementDepthCount","getBindingsEnabled","isInSkipHydrationBlock","isSkipHydrationRootTNode","ɵɵenableBindings","enterSkipHydrationBlock","ɵɵdisableBindings","leaveSkipHydrationBlock","getLView","getTView","ɵɵrestoreView","viewToRestore","contextLView","ɵɵresetView","getCurrentTNode","currentTNode","getCurrentTNodePlaceholderOk","getCurrentParentTNode","isParent","setCurrentTNode","isCurrentTNodeParent","setCurrentTNodeAsNotParent","getContextLView","isInCheckNoChangesMode","Off","isExhaustiveCheckNoChanges","Exhaustive","setIsInCheckNoChangesMode","mode","isRefreshingViews","setIsRefreshingViews","prev","getBindingRoot","bindingRootIndex","getBindingIndex","bindingIndex","setBindingIndex","nextBindingIndex","incrementBindingIndex","isInI18nBlock","inI18n","setInI18nBlock","setBindingRootForHostBindings","currentDirectiveIndex","setCurrentDirectiveIndex","getCurrentDirectiveIndex","getCurrentDirectiveDef","getCurrentQueryIndex","currentQueryIndex","setCurrentQueryIndex","getDeclarationTNode","declTNode","enterDI","parentTNode","parentLView","allocLFrame","enterView","newView","newLFrame","selectedIndex","currentNamespace","firstChild","currentLFrame","childLFrame","child","leaveViewLight","oldLFrame","leaveDI","leaveView","nextContextImpl","level","getSelectedIndex","setSelectedIndex","getSelectedTNode","ɵɵnamespaceSVG","ɵɵnamespaceMathML","ɵɵnamespaceHTML","namespaceHTMLInternal","getNamespace","_wasLastNodeCreated","wasLastNodeCreated","lastNodeWasCreated","createInjector","additionalProviders","createInjectorWithoutInjectorInstances","Injector","NULL","create","DOCUMENT","DestroyRef","injectDestroyRef","NodeInjectorDestroyRef","_lView","SCHEDULE_IN_ROOT_ZONE_DEFAULT","PendingTasksInternal","taskId","pendingTasks","pendingTask","hasPendingTasks","hasPendingTasksObservable","subscriber","next","complete","remove","delete","unsubscribe","EventEmitter_","__isAsync","destroyRef","isAsync","emit","subscribe","observerOrNext","nextFn","errorFn","completeFn","observer","bind","wrapInTimeout","sink","setTimeout","EventEmitter","noop","scheduleCallbackWithRafRace","timeoutId","animationFrameId","cancelAnimationFrame","clearTimeout","requestAnimationFrame","scheduleCallbackWithMicrotask","queueMicrotask","AsyncStackTaggingZoneSpec","createTask","namePrefix","consoleAsyncStackTaggingImpl","onScheduleTask","delegate","_current","task","consoleTask","scheduleTask","onInvokeTask","_currentZone","targetZone","applyThis","applyArgs","ret","run","invokeTask","isAngularZoneProperty","angularZoneInstanceIdProperty","ngZoneInstanceId","NgZone","hasPendingMacrotasks","hasPendingMicrotasks","isStable","onUnstable","onMicrotaskEmpty","onStable","onError","enableLongStackTrace","shouldCoalesceEventChangeDetection","shouldCoalesceRunChangeDetection","scheduleInRootZone","Zone","assertZonePatched","_nesting","_outer","_inner","fork","callbackScheduled","forkInnerZoneWithAngularBehavior","isInAngularZone","assertInAngularZone","assertNotInAngularZone","runTask","zone","scheduleEventTask","EMPTY_PAYLOAD","cancelTask","runGuarded","runOutsideAngular","checkStable","delayChangeDetectionForEvents","isCheckStableRunning","scheduleCheckStable","updateMicroTaskStatus","root","delayChangeDetectionForEventsDelegate","instanceId","properties","shouldBeIgnoredByZone","onEnter","onLeave","onInvoke","invoke","isSchedulerTick","onHasTask","hasTaskState","hasTask","change","_hasPendingMicrotasks","microTask","macroTask","onHandleError","handleError","NoopNgZone","apply","hasApplyArgsData","ErrorHandler","_console","INTERNAL_APPLICATION_ERROR_HANDLER","userErrorHandler","errorHandlerEnvironmentInitializer","handler","globalErrorListeners","ngServerMode","window","defaultView","errorHandler","rejectionListener","reason","preventDefault","errorListener","cause","setupEventListeners","addEventListener","removeEventListener","provideBrowserGlobalErrorListeners","ɵunwrapWritableSignal","signal","initialValue","update","equal","signalFn","asReadonly","signalAsReadonlyFn","debugName","readonlyFn","assertNotInReactiveContext","extraContext","ViewContext","injectViewContext","ChangeDetectionScheduler","ZONELESS_ENABLED","PROVIDED_ZONELESS","SCHEDULE_IN_ROOT_ZONE","PendingTasks","internalPendingTasks","scheduler","removeTask","catch","finally","EffectScheduler","ZoneAwareEffectScheduler","dirtyEffectCount","queues","handle","enqueue","schedule","queue","flush","ranOneEffect","flushQueue","EffectRefImpl","effectFn","allowSignalWrites","manualCleanup","viewContext","notifier","createViewEffect","createRootEffect","onDestroyFns","effectRef","EFFECT_NODE","cleanupFns","prevRefreshingViews","ROOT_EFFECT_NODE","consumerMarkedDirty","VIEW_EFFECT_NODE","createEffectFn","nonReactiveReadsFn"],"sources":["/Users/ariez/Downloads/crud/node_modules/@angular/core/fesm2022/_untracked-chunk.mjs"],"sourcesContent":["/**\n * @license Angular v21.0.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { getActiveConsumer, setActiveConsumer as setActiveConsumer$1, createSignal, SIGNAL, consumerDestroy, BASE_EFFECT_NODE, isInNotificationPhase, runEffect, untracked as untracked$1 } from './_effect-chunk.mjs';\nimport { BehaviorSubject, Observable, Subject, Subscription } from 'rxjs';\nimport { isNotFound, getCurrentInjector, setCurrentInjector } from './_not_found-chunk.mjs';\nimport { setActiveConsumer } from '@angular/core/primitives/signals';\nimport { isNotFound as isNotFound$1 } from '@angular/core/primitives/di';\n\nclass Version {\n  full;\n  major;\n  minor;\n  patch;\n  constructor(full) {\n    this.full = full;\n    const parts = full.split('.');\n    this.major = parts[0];\n    this.minor = parts[1];\n    this.patch = parts.slice(2).join('.');\n  }\n}\nconst VERSION = /* @__PURE__ */new Version('21.0.6');\n\nconst ERROR_DETAILS_PAGE_BASE_URL = (() => {\n  const versionSubDomain = VERSION.major !== '0' ? `v${VERSION.major}.` : '';\n  return `https://${versionSubDomain}angular.dev/errors`;\n})();\nconst XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';\n\nclass RuntimeError extends Error {\n  code;\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\nfunction formatRuntimeErrorCode(code) {\n  return `NG0${Math.abs(code)}`;\n}\nfunction formatRuntimeError(code, message) {\n  const fullCode = formatRuntimeErrorCode(code);\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n\nconst _global = globalThis;\n\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0,\n    deferBlocksWithIncrementalHydration: 0\n  };\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  if (!allowNgDevModeTrue) {\n    _global['ngDevMode'] = false;\n  } else {\n    if (typeof _global['ngDevMode'] !== 'object') {\n      _global['ngDevMode'] = {};\n    }\n    Object.assign(_global['ngDevMode'], newCounters);\n  }\n  return newCounters;\n}\nfunction initNgDevMode() {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n      return key;\n    }\n  }\n  throw Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Could not find renamed property on target object.' : '');\n}\nfunction fillProperties(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(', ')}]`;\n  }\n  if (token == null) {\n    return '' + token;\n  }\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n  const result = token.toString();\n  if (result == null) {\n    return '' + result;\n  }\n  const newLineIndex = result.indexOf('\\n');\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\nfunction concatStringsWithSpace(before, after) {\n  if (!before) return after || '';\n  if (!after) return before;\n  return `${before} ${after}`;\n}\nfunction truncateMiddle(str, maxLength = 100) {\n  if (!str || maxLength < 1 || str.length <= maxLength) return str;\n  if (maxLength == 1) return str.substring(0, 1) + '...';\n  const halfLimit = Math.round(maxLength / 2);\n  return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);\n}\n\nconst __forward_ref__ = getClosureSafeProperty({\n  __forward_ref__: getClosureSafeProperty\n});\nfunction forwardRef(forwardRefFn) {\n  forwardRefFn.__forward_ref__ = forwardRef;\n  forwardRefFn.toString = function () {\n    return stringify(this());\n  };\n  return forwardRefFn;\n}\nfunction resolveForwardRef(type) {\n  return isForwardRef(type) ? type() : type;\n}\nfunction isForwardRef(fn) {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;\n}\n\nfunction assertNumber(actual, msg) {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\nfunction assertFunction(actual, msg) {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\nfunction assertEqual(actual, expected, msg) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\nfunction assertNotEqual(actual, expected, msg) {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\nfunction assertSame(actual, expected, msg) {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\nfunction assertNotSame(actual, expected, msg) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\nfunction assertLessThan(actual, expected, msg) {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\nfunction assertNotDefined(actual, msg) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\nfunction assertDefined(actual, msg) {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\nfunction throwError(msg, actual, expected, comparison) {\n  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n  if (!(node instanceof Node)) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\nfunction assertElement(node) {\n  if (!(node instanceof Element)) {\n    throwError(`The provided value must be an element but got ${stringify(node)}`);\n  }\n}\nfunction assertIndexInRange(arr, index) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\nfunction assertOneOf(value, ...validValues) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\nfunction assertNotReactive(fn) {\n  if (getActiveConsumer() !== null) {\n    throwError(`${fn}() should never be called in a reactive context.`);\n  }\n}\n\nfunction ɵɵdefineInjectable(opts) {\n  return {\n    token: opts.token,\n    providedIn: opts.providedIn || null,\n    factory: opts.factory,\n    value: undefined\n  };\n}\nfunction ɵɵdefineInjector(options) {\n  return {\n    providers: options.providers || [],\n    imports: options.imports || []\n  };\n}\nfunction getInjectableDef(type) {\n  return getOwnDefinition(type, NG_PROV_DEF);\n}\nfunction isInjectable(type) {\n  return getInjectableDef(type) !== null;\n}\nfunction getOwnDefinition(type, field) {\n  return type.hasOwnProperty(field) && type[field] || null;\n}\nfunction getInheritedInjectableDef(type) {\n  const def = type?.[NG_PROV_DEF] ?? null;\n  if (def) {\n    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\nfunction getInjectorDef(type) {\n  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({\n  ɵprov: getClosureSafeProperty\n});\nconst NG_INJ_DEF = getClosureSafeProperty({\n  ɵinj: getClosureSafeProperty\n});\n\nclass InjectionToken {\n  _desc;\n  ngMetadataName = 'InjectionToken';\n  ɵprov;\n  constructor(_desc, options) {\n    this._desc = _desc;\n    this.ɵprov = undefined;\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');\n      this.__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory\n      });\n    }\n  }\n  get multi() {\n    return this;\n  }\n  toString() {\n    return `InjectionToken ${this._desc}`;\n  }\n}\n\nlet _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n  return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context) {\n  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n  const previous = _injectorProfilerContext;\n  _injectorProfilerContext = context;\n  return previous;\n}\nconst injectorProfilerCallbacks = [];\nconst NOOP_PROFILER_REMOVAL = () => {};\nfunction removeProfiler(profiler) {\n  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\n  if (profilerIdx !== -1) {\n    injectorProfilerCallbacks.splice(profilerIdx, 1);\n  }\n}\nfunction setInjectorProfiler(injectorProfiler) {\n  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n  if (injectorProfiler !== null) {\n    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\n      injectorProfilerCallbacks.push(injectorProfiler);\n    }\n    return () => removeProfiler(injectorProfiler);\n  } else {\n    injectorProfilerCallbacks.length = 0;\n    return NOOP_PROFILER_REMOVAL;\n  }\n}\nfunction injectorProfiler(event) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\n    const injectorProfilerCallback = injectorProfilerCallbacks[i];\n    injectorProfilerCallback(event);\n  }\n}\nfunction emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  let token;\n  if (typeof eventProvider === 'function') {\n    token = eventProvider;\n  } else if (eventProvider instanceof InjectionToken) {\n    token = eventProvider;\n  } else {\n    token = resolveForwardRef(eventProvider.provide);\n  }\n  let provider = eventProvider;\n  if (eventProvider instanceof InjectionToken) {\n    provider = eventProvider.ɵprov || eventProvider;\n  }\n  injectorProfiler({\n    type: 2,\n    context: getInjectorProfilerContext(),\n    providerRecord: {\n      token,\n      provider,\n      isViewProvider\n    }\n  });\n}\nfunction emitInjectorToCreateInstanceEvent(token) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 5,\n    context: getInjectorProfilerContext(),\n    token: token\n  });\n}\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 1,\n    context: getInjectorProfilerContext(),\n    instance: {\n      value: instance\n    }\n  });\n}\nfunction emitInjectEvent(token, value, flags) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 0,\n    context: getInjectorProfilerContext(),\n    service: {\n      token,\n      value,\n      flags\n    }\n  });\n}\nfunction emitEffectCreatedEvent(effect) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 3,\n    context: getInjectorProfilerContext(),\n    effect\n  });\n}\nfunction emitAfterRenderEffectPhaseCreatedEvent(effectPhase) {\n  !ngDevMode && throwError('Injector profiler should never be called in production mode');\n  injectorProfiler({\n    type: 4,\n    context: getInjectorProfilerContext(),\n    effectPhase\n  });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n  !ngDevMode && throwError('runInInjectorProfilerContext should never be called in production mode');\n  const prevInjectContext = setInjectorProfilerContext({\n    injector,\n    token\n  });\n  try {\n    callback();\n  } finally {\n    setInjectorProfilerContext(prevInjectContext);\n  }\n}\n\nfunction isEnvironmentProviders(value) {\n  return value && !!value.ɵproviders;\n}\n\nconst NG_COMP_DEF = getClosureSafeProperty({\n  ɵcmp: getClosureSafeProperty\n});\nconst NG_DIR_DEF = getClosureSafeProperty({\n  ɵdir: getClosureSafeProperty\n});\nconst NG_PIPE_DEF = getClosureSafeProperty({\n  ɵpipe: getClosureSafeProperty\n});\nconst NG_MOD_DEF = getClosureSafeProperty({\n  ɵmod: getClosureSafeProperty\n});\nconst NG_FACTORY_DEF = getClosureSafeProperty({\n  ɵfac: getClosureSafeProperty\n});\nconst NG_ELEMENT_ID = getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty\n});\nconst NG_ENV_ID = getClosureSafeProperty({\n  __NG_ENV_ID__: getClosureSafeProperty\n});\n\nfunction getNgModuleDef(type) {\n  assertTypeDefined(type, '@NgModule');\n  return type[NG_MOD_DEF] || null;\n}\nfunction getNgModuleDefOrThrow(type) {\n  const ngModuleDef = getNgModuleDef(type);\n  if (!ngModuleDef) {\n    throw new RuntimeError(915, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n  return ngModuleDef;\n}\nfunction getComponentDef(type) {\n  assertTypeDefined(type, '@Component');\n  return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDefOrThrow(type) {\n  const def = getDirectiveDef(type);\n  if (!def) {\n    throw new RuntimeError(916, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵdir' property.`);\n  }\n  return def;\n}\nfunction getDirectiveDef(type) {\n  assertTypeDefined(type, '@Directive');\n  return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef(type) {\n  assertTypeDefined(type, '@Pipe');\n  return type[NG_PIPE_DEF] || null;\n}\nfunction assertTypeDefined(type, symbolType) {\n  if (type == null) {\n    throw new RuntimeError(-919, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot read ${symbolType} metadata. This can indicate a runtime ` + `circular dependency in your app that needs to be resolved.`);\n  }\n}\nfunction isStandalone(type) {\n  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n  return def !== null && def.standalone;\n}\n\nfunction renderStringify(value) {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  return String(value);\n}\nfunction stringifyForError(value) {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n  return renderStringify(value);\n}\nfunction debugStringifyTypeForError(type) {\n  const componentDef = getComponentDef(type);\n  if (componentDef !== null && componentDef.debugInfo) {\n    return stringifyTypeFromDebugInfo(componentDef.debugInfo);\n  }\n  return stringifyForError(type);\n}\nfunction stringifyTypeFromDebugInfo(debugInfo) {\n  if (!debugInfo.filePath || !debugInfo.lineNumber) {\n    return debugInfo.className;\n  } else {\n    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;\n  }\n}\n\nconst NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({\n  'ngErrorCode': getClosureSafeProperty\n});\nconst NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({\n  'ngErrorMessage': getClosureSafeProperty\n});\nconst NG_TOKEN_PATH = getClosureSafeProperty({\n  'ngTokenPath': getClosureSafeProperty\n});\nfunction cyclicDependencyError(token, path) {\n  const message = ngDevMode ? `Circular dependency detected for \\`${token}\\`.` : '';\n  return createRuntimeError(message, -200, path);\n}\nfunction cyclicDependencyErrorWithDetails(token, path) {\n  return augmentRuntimeError(cyclicDependencyError(token, path), null);\n}\nfunction throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n  } else if (isEnvironmentProviders(provider)) {\n    if (provider.ɵfromNgModule) {\n      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    } else {\n      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n    }\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\nfunction throwProviderNotFoundError(token, injectorName) {\n  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;\n  throw new RuntimeError(-201, errorMessage);\n}\nfunction prependTokenToDependencyPath(error, token) {\n  error[NG_TOKEN_PATH] ??= [];\n  const currentPath = error[NG_TOKEN_PATH];\n  let pathStr;\n  if (typeof token === 'object' && 'multi' in token && token?.multi === true) {\n    assertDefined(token.provide, 'Token with multi: true should have a provide property');\n    pathStr = stringifyForError(token.provide);\n  } else {\n    pathStr = stringifyForError(token);\n  }\n  if (currentPath[0] !== pathStr) {\n    error[NG_TOKEN_PATH].unshift(pathStr);\n  }\n}\nfunction augmentRuntimeError(error, source) {\n  const tokenPath = error[NG_TOKEN_PATH];\n  const errorCode = error[NG_RUNTIME_ERROR_CODE];\n  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;\n  error.message = formatErrorMessage(message, errorCode, tokenPath, source);\n  return error;\n}\nfunction createRuntimeError(message, code, path) {\n  const error = new RuntimeError(code, message);\n  error[NG_RUNTIME_ERROR_CODE] = code;\n  error[NG_RUNTIME_ERROR_MESSAGE] = message;\n  if (path) {\n    error[NG_TOKEN_PATH] = path;\n  }\n  return error;\n}\nfunction getRuntimeErrorCode(error) {\n  return error[NG_RUNTIME_ERROR_CODE];\n}\nfunction formatErrorMessage(text, code, path = [], source = null) {\n  let pathDetails = '';\n  if (path && path.length > 1) {\n    pathDetails = ` Path: ${path.join(' -> ')}.`;\n  }\n  const sourceDetails = source ? ` Source: ${source}.` : '';\n  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);\n}\n\nlet _injectImplementation;\nfunction getInjectImplementation() {\n  return _injectImplementation;\n}\nfunction setInjectImplementation(impl) {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n  const injectableDef = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;\n  }\n  if (flags & 8) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(token, typeof ngDevMode !== 'undefined' && ngDevMode ? 'Injector' : '');\n}\nfunction assertInjectImplementationNotEqual(fn) {\n  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nclass RetrievingInjector {\n  injector;\n  constructor(injector) {\n    this.injector = injector;\n  }\n  retrieve(token, options) {\n    const flags = convertToBitFlags(options) || 0;\n    try {\n      return this.injector.get(token, flags & 8 ? null : THROW_IF_NOT_FOUND, flags);\n    } catch (e) {\n      if (isNotFound(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n}\nfunction injectInjectorOnly(token, flags = 0) {\n  const currentInjector = getCurrentInjector();\n  if (currentInjector === undefined) {\n    throw new RuntimeError(-203, ngDevMode && `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n  } else if (currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    const options = convertToInjectOptions(flags);\n    const value = currentInjector.retrieve(token, options);\n    ngDevMode && emitInjectEvent(token, value, flags);\n    if (isNotFound(value)) {\n      if (options.optional) {\n        return null;\n      }\n      throw value;\n    }\n    return value;\n  }\n}\nfunction ɵɵinject(token, flags = 0) {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\nfunction ɵɵinvalidFactoryDep(index) {\n  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\nfunction inject(token, options) {\n  return ɵɵinject(token, convertToBitFlags(options));\n}\nfunction convertToBitFlags(flags) {\n  if (typeof flags === 'undefined' || typeof flags === 'number') {\n    return flags;\n  }\n  return 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);\n}\nfunction convertToInjectOptions(flags) {\n  return {\n    optional: !!(flags & 8),\n    host: !!(flags & 1),\n    self: !!(flags & 2),\n    skipSelf: !!(flags & 4)\n  };\n}\nfunction injectArgs(types) {\n  const args = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(900, ngDevMode && 'Arguments array must have arguments.');\n      }\n      let type = undefined;\n      let flags = 0;\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === 'number') {\n          if (flag === -1) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n      args.push(ɵɵinject(type, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\nfunction attachInjectFlag(decorator, flag) {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\nfunction getInjectFlag(token) {\n  return token[DI_DECORATOR_FLAG];\n}\n\nfunction getFactoryDef(type, throwNotFound) {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\nfunction arrayEquals(a, b, identityAccessor) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA);\n      valueB = identityAccessor(valueB);\n    }\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction flatten(list) {\n  return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\nfunction removeFromArray(arr, index) {\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\nfunction newArray(size, value) {\n  const list = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value);\n  }\n  return list;\n}\nfunction arraySplice(array, index, count) {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop();\n  }\n}\nfunction arrayInsert2(array, index, value1, value2) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n  let end = array.length;\n  if (end == index) {\n    array.push(value1, value2);\n  } else if (end === 1) {\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\nfunction keyValueArraySet(keyValueArray, key, value) {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\nfunction keyValueArrayGet(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    return keyValueArray[index | 1];\n  }\n  return undefined;\n}\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n  return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\nfunction _arrayIndexOfSorted(array, value, shift) {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + (end - start >> 1);\n    const current = array[middle << shift];\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1;\n    }\n  }\n  return ~(end << shift);\n}\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  Object.freeze(EMPTY_OBJ);\n  Object.freeze(EMPTY_ARRAY);\n}\n\nconst ENVIRONMENT_INITIALIZER = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');\n\nconst INJECTOR$1 = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR' : '', -1);\n\nconst INJECTOR_DEF_TYPES = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR_DEF_TYPES' : '');\n\nclass NullInjector {\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const message = ngDevMode ? `No provider found for \\`${stringify(token)}\\`.` : '';\n      const error = createRuntimeError(message, -201);\n      error.name = 'ɵNotFound';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n\nfunction makeEnvironmentProviders(providers) {\n  return {\n    ɵproviders: providers\n  };\n}\nfunction provideEnvironmentInitializer(initializerFn) {\n  return makeEnvironmentProviders([{\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useValue: initializerFn\n  }]);\n}\nfunction importProvidersFrom(...sources) {\n  return {\n    ɵproviders: internalImportProvidersFrom(true, sources),\n    ɵfromNgModule: true\n  };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n  const providersOut = [];\n  const dedup = new Set();\n  let injectorTypesWithProviders;\n  const collectProviders = provider => {\n    providersOut.push(provider);\n  };\n  deepForEach(sources, source => {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef(source);\n      if (cmpDef?.standalone) {\n        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n      }\n    }\n    const internalSource = source;\n    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n      injectorTypesWithProviders ||= [];\n      injectorTypesWithProviders.push(internalSource);\n    }\n  });\n  if (injectorTypesWithProviders !== undefined) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n  }\n  return providersOut;\n}\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {\n      ngModule,\n      providers\n    } = typesWithProviders[i];\n    deepForEachProvider(providers, provider => {\n      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n      visitor(provider, ngModule);\n    });\n  }\n}\nfunction walkProviderTree(container, visitor, parents, dedup) {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n  let defType = null;\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef(container);\n  if (!injDef && !cmpDef) {\n    const ngModule = container.ngModule;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule;\n    } else {\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container;\n  }\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify).concat(defName);\n    throw cyclicDependencyErrorWithDetails(defName, path);\n  }\n  const isDuplicate = dedup.has(defType);\n  if (cmpDef) {\n    if (isDuplicate) {\n      return false;\n    }\n    dedup.add(defType);\n    if (cmpDef.dependencies) {\n      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, visitor, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    if (injDef.imports != null && !isDuplicate) {\n      ngDevMode && parents.push(defType);\n      dedup.add(defType);\n      let importTypesWithProviders;\n      try {\n        deepForEach(injDef.imports, imported => {\n          if (walkProviderTree(imported, visitor, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        ngDevMode && parents.pop();\n      }\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n      }\n    }\n    if (!isDuplicate) {\n      const factory = getFactoryDef(defType) || (() => new defType());\n      visitor({\n        provide: defType,\n        useFactory: factory,\n        deps: EMPTY_ARRAY\n      }, defType);\n      visitor({\n        provide: INJECTOR_DEF_TYPES,\n        useValue: defType,\n        multi: true\n      }, defType);\n      visitor({\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => ɵɵinject(defType),\n        multi: true\n      }, defType);\n    }\n    const defProviders = injDef.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container;\n      deepForEachProvider(defProviders, provider => {\n        ngDevMode && validateProvider(provider, defProviders, injectorType);\n        visitor(provider, injectorType);\n      });\n    }\n  } else {\n    return false;\n  }\n  return defType !== container && container.providers !== undefined;\n}\nfunction validateProvider(provider, providers, containerType) {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {\n    return;\n  }\n  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\nfunction deepForEachProvider(providers, fn) {\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      deepForEachProvider(provider, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nconst USE_VALUE = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isValueProvider(value) {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\nfunction isExistingProvider(value) {\n  return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n  return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n  return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n  return !!value.useClass;\n}\n\nconst INJECTOR_SCOPE = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Set Injector scope.' : '');\n\nconst NOT_YET = {};\nconst CIRCULAR = {};\nlet NULL_INJECTOR = undefined;\nfunction getNullInjector() {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\nclass EnvironmentInjector {}\nclass R3Injector extends EnvironmentInjector {\n  parent;\n  source;\n  scopes;\n  records = new Map();\n  _ngOnDestroyHooks = new Set();\n  _onDestroyHooks = [];\n  get destroyed() {\n    return this._destroyed;\n  }\n  _destroyed = false;\n  injectorDefTypes;\n  constructor(providers, parent, source, scopes) {\n    super();\n    this.parent = parent;\n    this.source = source;\n    this.scopes = scopes;\n    forEachSingleProvider(providers, provider => this.processProvider(provider));\n    this.records.set(INJECTOR$1, makeRecord(undefined, this));\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    }\n    const record = this.records.get(INJECTOR_SCOPE);\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value);\n    }\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, {\n      self: true\n    }));\n  }\n  retrieve(token, options) {\n    const flags = convertToBitFlags(options) || 0;\n    try {\n      return this.get(token, THROW_IF_NOT_FOUND, flags);\n    } catch (e) {\n      if (isNotFound$1(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  destroy() {\n    assertNotDestroyed(this);\n    this._destroyed = true;\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      const onDestroyHooks = this._onDestroyHooks;\n      this._onDestroyHooks = [];\n      for (const hook of onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  onDestroy(callback) {\n    assertNotDestroyed(this);\n    this._onDestroyHooks.push(callback);\n    return () => this.removeOnDestroy(callback);\n  }\n  runInContext(fn) {\n    assertNotDestroyed(this);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {\n    assertNotDestroyed(this);\n    if (token.hasOwnProperty(NG_ENV_ID)) {\n      return token[NG_ENV_ID](this);\n    }\n    const flags = convertToBitFlags(options);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: token\n      });\n    }\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (!(flags & 4)) {\n        let record = this.records.get(token);\n        if (record === undefined) {\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            if (ngDevMode) {\n              runInInjectorProfilerContext(this, token, () => {\n                emitProviderConfiguredEvent(token);\n              });\n            }\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        if (record != null) {\n          return this.hydrate(token, record, flags);\n        }\n      }\n      const nextInjector = !(flags & 2) ? this.parent : getNullInjector();\n      notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (error) {\n      const errorCode = getRuntimeErrorCode(error);\n      if (errorCode === -200 || errorCode === -201) {\n        if (ngDevMode) {\n          prependTokenToDependencyPath(error, token);\n          if (previousInjector) {\n            throw error;\n          } else {\n            throw augmentRuntimeError(error, this.source);\n          }\n        } else {\n          throw new RuntimeError(errorCode, null);\n        }\n      } else {\n        throw error;\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  resolveInjectorInitializers() {\n    const prevConsumer = setActiveConsumer(null);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, {\n        self: true\n      });\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(-209, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  toString() {\n    const tokens = [];\n    const records = this.records;\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n  processProvider(provider) {\n    provider = resolveForwardRef(provider);\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n    const record = providerToRecord(provider);\n    if (ngDevMode) {\n      runInInjectorProfilerContext(this, token, () => {\n        if (isValueProvider(provider)) {\n          emitInjectorToCreateInstanceEvent(token);\n          emitInstanceCreatedByInjectorEvent(provider.useValue);\n        }\n        emitProviderConfiguredEvent(provider);\n      });\n    }\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord.multi);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi.push(provider);\n    } else {\n      if (ngDevMode) {\n        const existing = this.records.get(token);\n        if (existing && existing.multi !== undefined) {\n          throwMixedMultiProviderError();\n        }\n      }\n    }\n    this.records.set(token, record);\n  }\n  hydrate(token, record, flags) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      if (record.value === CIRCULAR) {\n        throw cyclicDependencyError(stringify(token));\n      } else if (record.value === NOT_YET) {\n        record.value = CIRCULAR;\n        if (ngDevMode) {\n          runInInjectorProfilerContext(this, token, () => {\n            emitInjectorToCreateInstanceEvent(token);\n            record.value = record.factory(undefined, flags);\n            emitInstanceCreatedByInjectorEvent(record.value);\n          });\n        } else {\n          record.value = record.factory(undefined, flags);\n        }\n      }\n      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n        this._ngOnDestroyHooks.add(record.value);\n      }\n      return record.value;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  injectableDefInScope(def) {\n    if (!def.providedIn) {\n      return false;\n    }\n    const providedIn = resolveForwardRef(def.providedIn);\n    if (typeof providedIn === 'string') {\n      return providedIn === 'any' || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n  removeOnDestroy(callback) {\n    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n    if (destroyCBIdx !== -1) {\n      this._onDestroyHooks.splice(destroyCBIdx, 1);\n    }\n  }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n  if (factory !== null) {\n    return factory;\n  }\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n  }\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n  throw new RuntimeError(204, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);\n  }\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token);\n  } else {\n    return () => new token();\n  }\n}\nfunction providerToRecord(provider) {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory = providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\nfunction providerToFactory(provider, ngModuleType, providers) {\n  let factory = undefined;\n  if (ngDevMode && isEnvironmentProviders(provider)) {\n    throwInvalidProviderError(undefined, providers, provider);\n  }\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 ? 8 : undefined);\n    } else {\n      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\nfunction assertNotDestroyed(injector) {\n  if (injector.destroyed) {\n    throw new RuntimeError(205, ngDevMode && 'Injector has already been destroyed.');\n  }\n}\nfunction makeRecord(factory, value, multi = false) {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined\n  };\n}\nfunction hasDeps(value) {\n  return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n  return typeof value === 'function' || typeof value === 'object' && value.ngMetadataName === 'InjectionToken';\n}\nfunction forEachSingleProvider(providers, fn) {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (provider && isEnvironmentProviders(provider)) {\n      forEachSingleProvider(provider.ɵproviders, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\n\nfunction runInInjectionContext(injector, fn) {\n  let internalInjector;\n  if (injector instanceof R3Injector) {\n    assertNotDestroyed(injector);\n    internalInjector = injector;\n  } else {\n    internalInjector = new RetrievingInjector(injector);\n  }\n  let prevInjectorProfilerContext;\n  if (ngDevMode) {\n    prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n  }\n  const prevInjector = setCurrentInjector(internalInjector);\n  const previousInjectImplementation = setInjectImplementation(undefined);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\nfunction isInInjectionContext() {\n  return getInjectImplementation() !== undefined || getCurrentInjector() != null;\n}\nfunction assertInInjectionContext(debugFn) {\n  if (!isInInjectionContext()) {\n    throw new RuntimeError(-203, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\n  }\n}\n\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst T_HOST = 5;\nconst HYDRATION = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst EFFECTS_TO_SCHEDULE = 22;\nconst EFFECTS = 23;\nconst REACTIVE_TEMPLATE_CONSUMER = 24;\nconst AFTER_RENDER_SEQUENCES_TO_ADD = 25;\nconst ANIMATIONS = 26;\nconst HEADER_OFFSET = 27;\n\nconst TYPE = 1;\nconst DEHYDRATED_VIEWS = 6;\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\nconst CONTAINER_HEADER_OFFSET = 10;\n\nfunction isLView(value) {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\nfunction isLContainer(value) {\n  return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n  return (tNode.flags & 4) !== 0;\n}\nfunction isComponentHost(tNode) {\n  return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n  return (tNode.flags & 1) === 1;\n}\nfunction isComponentDef(def) {\n  return !!def.template;\n}\nfunction isRootView(target) {\n  return (target[FLAGS] & 512) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n  return (tNode.type & 16) === 16;\n}\nfunction hasI18n(lView) {\n  return (lView[FLAGS] & 32) === 32;\n}\nfunction isDestroyed(lView) {\n  return (lView[FLAGS] & 256) === 256;\n}\n\nfunction assertTNodeForLView(tNode, lView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeCreationIndex(lView, index) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  assertIndexInRange(lView, adjustedIndex);\n  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');\n}\nfunction assertTNodeForTView(tNode, tView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n  assertDefined(tNode, 'TNode must be defined');\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\nfunction assertTIcu(tIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\nfunction assertComponentType(actual, msg = \"Type passed in is not ComponentType, it does not have 'ɵcmp' property.\") {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertNgModuleType(actual, msg = \"Type passed in is not NgModuleType, it does not have 'ɵmod' property.\") {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\nfunction assertHasParent(tNode) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n  assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');\n}\nfunction assertDirectiveDef(obj) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\nfunction assertIndexInDeclRange(tView, index) {\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n  assertDefined(lView, \"Component views should always have a parent view (component's host view)\");\n}\nfunction assertNodeInjector(lView, injectorIndex) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + 8);\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');\n}\n\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\n\nfunction unwrapRNode(value) {\n  while (Array.isArray(value)) {\n    value = value[HOST];\n  }\n  return value;\n}\nfunction unwrapLView(value) {\n  while (Array.isArray(value)) {\n    if (typeof value[TYPE] === 'object') return value;\n    value = value[HOST];\n  }\n  return null;\n}\nfunction getNativeByIndex(index, lView) {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\nfunction getNativeByTNode(tNode, lView) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node = unwrapRNode(lView[tNode.index]);\n  return node;\n}\nfunction getNativeByTNodeOrNull(tNode, lView) {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node = unwrapRNode(lView[index]);\n    return node;\n  }\n  return null;\n}\nfunction getTNode(tView, index) {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index];\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\nfunction load(view, index) {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\nfunction store(tView, lView, index, value) {\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n  lView[index] = value;\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\nfunction isCreationMode(view) {\n  return (view[FLAGS] & 4) === 4;\n}\nfunction viewAttachedToChangeDetector(view) {\n  return (view[FLAGS] & 128) === 128;\n}\nfunction viewAttachedToContainer(view) {\n  return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts, index);\n  return consts[index];\n}\nfunction resetPreOrderHookFlags(lView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\nfunction markViewForRefresh(lView) {\n  if (lView[FLAGS] & 1024) {\n    return;\n  }\n  lView[FLAGS] |= 1024;\n  if (viewAttachedToChangeDetector(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\nfunction walkUpViews(nestingLevel, currentView) {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW];\n    nestingLevel--;\n  }\n  return currentView;\n}\nfunction requiresRefreshOrTraversal(lView) {\n  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);\n}\nfunction updateAncestorTraversalFlagsOnAttach(lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(8);\n  if (lView[FLAGS] & 64) {\n    lView[FLAGS] |= 1024;\n  }\n  if (requiresRefreshOrTraversal(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\nfunction markAncestorsForTraversal(lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(0);\n  let parent = getLViewParent(lView);\n  while (parent !== null) {\n    if (parent[FLAGS] & 8192) {\n      break;\n    }\n    parent[FLAGS] |= 8192;\n    if (!viewAttachedToChangeDetector(parent)) {\n      break;\n    }\n    parent = getLViewParent(parent);\n  }\n}\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n  if (isDestroyed(lView)) {\n    throw new RuntimeError(911, ngDevMode && 'View has already been destroyed.');\n  }\n  if (lView[ON_DESTROY_HOOKS] === null) {\n    lView[ON_DESTROY_HOOKS] = [];\n  }\n  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n  if (lView[ON_DESTROY_HOOKS] === null) return;\n  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n  if (destroyCBIdx !== -1) {\n    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n  }\n}\nfunction getLViewParent(lView) {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\nfunction getOrCreateLViewCleanup(view) {\n  return view[CLEANUP] ??= [];\n}\nfunction getOrCreateTViewCleanup(tView) {\n  return tView.cleanup ??= [];\n}\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n  lCleanup.push(context);\n  if (tView.firstCreatePass) {\n    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  } else {\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n  }\n}\n\nconst instructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null\n};\nvar CheckNoChangesMode;\n(function (CheckNoChangesMode) {\n  CheckNoChangesMode[CheckNoChangesMode[\"Off\"] = 0] = \"Off\";\n  CheckNoChangesMode[CheckNoChangesMode[\"Exhaustive\"] = 1] = \"Exhaustive\";\n  CheckNoChangesMode[CheckNoChangesMode[\"OnlyDirtyViews\"] = 2] = \"OnlyDirtyViews\";\n})(CheckNoChangesMode || (CheckNoChangesMode = {}));\nlet _checkNoChangesMode = 0;\nlet _isRefreshingViews = false;\nfunction getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n  return instructionState.bindingsEnabled;\n}\nfunction isInSkipHydrationBlock() {\n  return instructionState.skipHydrationRootTNode !== null;\n}\nfunction isSkipHydrationRootTNode(tNode) {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\nfunction ɵɵenableBindings() {\n  instructionState.bindingsEnabled = true;\n}\nfunction enterSkipHydrationBlock(tNode) {\n  instructionState.skipHydrationRootTNode = tNode;\n}\nfunction ɵɵdisableBindings() {\n  instructionState.bindingsEnabled = false;\n}\nfunction leaveSkipHydrationBlock() {\n  instructionState.skipHydrationRootTNode = null;\n}\nfunction getLView() {\n  return instructionState.lFrame.lView;\n}\nfunction getTView() {\n  return instructionState.lFrame.tView;\n}\nfunction ɵɵrestoreView(viewToRestore) {\n  instructionState.lFrame.contextLView = viewToRestore;\n  return viewToRestore[CONTEXT];\n}\nfunction ɵɵresetView(value) {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\nfunction getCurrentTNode() {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === 64) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n  return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n  return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n  instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\nfunction isExhaustiveCheckNoChanges() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _checkNoChangesMode = mode;\n}\nfunction isRefreshingViews() {\n  return _isRefreshingViews;\n}\nfunction setIsRefreshingViews(mode) {\n  const prev = _isRefreshingViews;\n  _isRefreshingViews = mode;\n  return prev;\n}\nfunction getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\nfunction getBindingIndex() {\n  return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n  return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n  return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\nfunction isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\nfunction getCurrentDirectiveIndex() {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\nfunction getCurrentDirectiveDef(tData) {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n  return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n  instructionState.lFrame.currentQueryIndex = value;\n}\nfunction getDeclarationTNode(lView) {\n  const tView = lView[TVIEW];\n  if (tView.type === 2) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n  if (tView.type === 1) {\n    return lView[T_HOST];\n  }\n  return null;\n}\nfunction enterDI(lView, tNode, flags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n  if (flags & 4) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n    let parentTNode = tNode;\n    let parentLView = lView;\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode.parent;\n      if (parentTNode === null && !(flags & 1)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW];\n        if (parentTNode.type & (2 | 8)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n  return true;\n}\nfunction enterView(newView) {\n  ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\nfunction createLFrame(parent) {\n  const lFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null,\n    tView: null,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent,\n    child: null,\n    inI18n: false\n  };\n  parent !== null && (parent.child = lFrame);\n  return lFrame;\n}\nfunction leaveViewLight() {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null;\n  oldLFrame.lView = null;\n  return oldLFrame;\n}\nconst leaveDI = leaveViewLight;\nfunction leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);\n  return contextLView[CONTEXT];\n}\nfunction getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\nfunction setSelectedIndex(index) {\n  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, \"Can't set index passed end of LView\");\n  instructionState.lFrame.selectedIndex = index;\n}\nfunction getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\nfunction ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\nfunction ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\nfunction ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\nfunction namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace() {\n  return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\nfunction wasLastNodeCreated() {\n  return _wasLastNodeCreated;\n}\nfunction lastNodeWasCreated(flag) {\n  _wasLastNodeCreated = flag;\n}\n\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\nclass Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL = new NullInjector();\n  static create(options, parent) {\n    if (Array.isArray(options)) {\n      return createInjector({\n        name: ''\n      }, parent, options, '');\n    } else {\n      const name = options.name ?? '';\n      return createInjector({\n        name\n      }, options.parent, options.providers, name);\n    }\n  }\n  static ɵprov =\n  /* @__PURE__ */\n  ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR$1)\n  });\n  static __NG_ELEMENT_ID__ = -1;\n}\n\nconst DOCUMENT = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DocumentToken' : '');\n\nclass DestroyRef {\n  static __NG_ELEMENT_ID__ = injectDestroyRef;\n  static __NG_ENV_ID__ = injector => injector;\n}\nclass NodeInjectorDestroyRef extends DestroyRef {\n  _lView;\n  constructor(_lView) {\n    super();\n    this._lView = _lView;\n  }\n  get destroyed() {\n    return isDestroyed(this._lView);\n  }\n  onDestroy(callback) {\n    const lView = this._lView;\n    storeLViewOnDestroy(lView, callback);\n    return () => removeLViewOnDestroy(lView, callback);\n  }\n}\nfunction injectDestroyRef() {\n  return new NodeInjectorDestroyRef(getLView());\n}\n\nconst SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;\n\nclass PendingTasksInternal {\n  taskId = 0;\n  pendingTasks = new Set();\n  destroyed = false;\n  pendingTask = new BehaviorSubject(false);\n  get hasPendingTasks() {\n    return this.destroyed ? false : this.pendingTask.value;\n  }\n  get hasPendingTasksObservable() {\n    if (this.destroyed) {\n      return new Observable(subscriber => {\n        subscriber.next(false);\n        subscriber.complete();\n      });\n    }\n    return this.pendingTask;\n  }\n  add() {\n    if (!this.hasPendingTasks && !this.destroyed) {\n      this.pendingTask.next(true);\n    }\n    const taskId = this.taskId++;\n    this.pendingTasks.add(taskId);\n    return taskId;\n  }\n  has(taskId) {\n    return this.pendingTasks.has(taskId);\n  }\n  remove(taskId) {\n    this.pendingTasks.delete(taskId);\n    if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\n      this.pendingTask.next(false);\n    }\n  }\n  ngOnDestroy() {\n    this.pendingTasks.clear();\n    if (this.hasPendingTasks) {\n      this.pendingTask.next(false);\n    }\n    this.destroyed = true;\n    this.pendingTask.unsubscribe();\n  }\n  static ɵprov =\n  /* @__PURE__ */\n  ɵɵdefineInjectable({\n    token: PendingTasksInternal,\n    providedIn: 'root',\n    factory: () => new PendingTasksInternal()\n  });\n}\n\nclass EventEmitter_ extends Subject {\n  __isAsync;\n  destroyRef = undefined;\n  pendingTasks = undefined;\n  constructor(isAsync = false) {\n    super();\n    this.__isAsync = isAsync;\n    if (isInInjectionContext()) {\n      this.destroyRef = inject(DestroyRef, {\n        optional: true\n      }) ?? undefined;\n      this.pendingTasks = inject(PendingTasksInternal, {\n        optional: true\n      }) ?? undefined;\n    }\n  }\n  emit(value) {\n    const prevConsumer = setActiveConsumer$1(null);\n    try {\n      super.next(value);\n    } finally {\n      setActiveConsumer$1(prevConsumer);\n    }\n  }\n  subscribe(observerOrNext, error, complete) {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n    if (this.__isAsync) {\n      errorFn = this.wrapInTimeout(errorFn);\n      if (nextFn) {\n        nextFn = this.wrapInTimeout(nextFn);\n      }\n      if (completeFn) {\n        completeFn = this.wrapInTimeout(completeFn);\n      }\n    }\n    const sink = super.subscribe({\n      next: nextFn,\n      error: errorFn,\n      complete: completeFn\n    });\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n    return sink;\n  }\n  wrapInTimeout(fn) {\n    return value => {\n      const taskId = this.pendingTasks?.add();\n      setTimeout(() => {\n        try {\n          fn(value);\n        } finally {\n          if (taskId !== undefined) {\n            this.pendingTasks?.remove(taskId);\n          }\n        }\n      });\n    };\n  }\n}\nconst EventEmitter = EventEmitter_;\n\nfunction noop(...args) {}\n\nfunction scheduleCallbackWithRafRace(callback) {\n  let timeoutId;\n  let animationFrameId;\n  function cleanup() {\n    callback = noop;\n    try {\n      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {\n        cancelAnimationFrame(animationFrameId);\n      }\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    } catch {}\n  }\n  timeoutId = setTimeout(() => {\n    callback();\n    cleanup();\n  });\n  if (typeof requestAnimationFrame === 'function') {\n    animationFrameId = requestAnimationFrame(() => {\n      callback();\n      cleanup();\n    });\n  }\n  return () => cleanup();\n}\nfunction scheduleCallbackWithMicrotask(callback) {\n  queueMicrotask(() => callback());\n  return () => {\n    callback = noop;\n  };\n}\n\nclass AsyncStackTaggingZoneSpec {\n  createTask;\n  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {\n    this.name = 'asyncStackTagging for ' + namePrefix;\n    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);\n  }\n  name;\n  onScheduleTask(delegate, _current, target, task) {\n    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);\n    return delegate.scheduleTask(target, task);\n  }\n  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {\n    let ret;\n    if (task.consoleTask) {\n      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));\n    } else {\n      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n    return ret;\n  }\n}\n\nconst isAngularZoneProperty = 'isAngularZone';\nconst angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';\nlet ngZoneInstanceId = 0;\nclass NgZone {\n  hasPendingMacrotasks = false;\n  hasPendingMicrotasks = false;\n  isStable = true;\n  onUnstable = new EventEmitter(false);\n  onMicrotaskEmpty = new EventEmitter(false);\n  onStable = new EventEmitter(false);\n  onError = new EventEmitter(false);\n  constructor(options) {\n    const {\n      enableLongStackTrace = false,\n      shouldCoalesceEventChangeDetection = false,\n      shouldCoalesceRunChangeDetection = false,\n      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT\n    } = options;\n    if (typeof Zone == 'undefined') {\n      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);\n    }\n    Zone.assertZonePatched();\n    const self = this;\n    self._nesting = 0;\n    self._outer = self._inner = Zone.current;\n    if (ngDevMode) {\n      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));\n    }\n    if (Zone['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());\n    }\n    if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);\n    }\n    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.callbackScheduled = false;\n    self.scheduleInRootZone = scheduleInRootZone;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n  static isInAngularZone() {\n    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;\n  }\n  static assertInAngularZone() {\n    if (!NgZone.isInAngularZone()) {\n      throw new RuntimeError(909, ngDevMode && 'Expected to be in Angular Zone, but it is not!');\n    }\n  }\n  static assertNotInAngularZone() {\n    if (NgZone.isInAngularZone()) {\n      throw new RuntimeError(909, ngDevMode && 'Expected to not be in Angular Zone, but it is!');\n    }\n  }\n  run(fn, applyThis, applyArgs) {\n    return this._inner.run(fn, applyThis, applyArgs);\n  }\n  runTask(fn, applyThis, applyArgs, name) {\n    const zone = this._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n  runGuarded(fn, applyThis, applyArgs) {\n    return this._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n  runOutsideAngular(fn) {\n    return this._outer.run(fn);\n  }\n}\nconst EMPTY_PAYLOAD = {};\nfunction checkStable(zone) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\nfunction delayChangeDetectionForEvents(zone) {\n  if (zone.isCheckStableRunning || zone.callbackScheduled) {\n    return;\n  }\n  zone.callbackScheduled = true;\n  function scheduleCheckStable() {\n    scheduleCallbackWithRafRace(() => {\n      zone.callbackScheduled = false;\n      updateMicroTaskStatus(zone);\n      zone.isCheckStableRunning = true;\n      checkStable(zone);\n      zone.isCheckStableRunning = false;\n    });\n  }\n  if (zone.scheduleInRootZone) {\n    Zone.root.run(() => {\n      scheduleCheckStable();\n    });\n  } else {\n    zone._outer.run(() => {\n      scheduleCheckStable();\n    });\n  }\n  updateMicroTaskStatus(zone);\n}\nfunction forkInnerZoneWithAngularBehavior(zone) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  const instanceId = ngZoneInstanceId++;\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: {\n      [isAngularZoneProperty]: true,\n      [angularZoneInstanceIdProperty]: instanceId,\n      [angularZoneInstanceIdProperty + instanceId]: true\n    },\n    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {\n      if (shouldBeIgnoredByZone(applyArgs)) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (zone.shouldCoalesceRunChangeDetection && !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onHasTask: (delegate, current, target, hasTaskState) => {\n      delegate.hasTask(target, hasTaskState);\n      if (current === target) {\n        if (hasTaskState.change == 'microTask') {\n          zone._hasPendingMicrotasks = hasTaskState.microTask;\n          updateMicroTaskStatus(zone);\n          checkStable(zone);\n        } else if (hasTaskState.change == 'macroTask') {\n          zone.hasPendingMacrotasks = hasTaskState.macroTask;\n        }\n      }\n    },\n    onHandleError: (delegate, current, target, error) => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\nfunction updateMicroTaskStatus(zone) {\n  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\nfunction onEnter(zone) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\nfunction onLeave(zone) {\n  zone._nesting--;\n  checkStable(zone);\n}\nclass NoopNgZone {\n  hasPendingMicrotasks = false;\n  hasPendingMacrotasks = false;\n  isStable = true;\n  onUnstable = new EventEmitter();\n  onMicrotaskEmpty = new EventEmitter();\n  onStable = new EventEmitter();\n  onError = new EventEmitter();\n  run(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runGuarded(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runOutsideAngular(fn) {\n    return fn();\n  }\n  runTask(fn, applyThis, applyArgs, name) {\n    return fn.apply(applyThis, applyArgs);\n  }\n}\nfunction shouldBeIgnoredByZone(applyArgs) {\n  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');\n}\nfunction isSchedulerTick(applyArgs) {\n  return hasApplyArgsData(applyArgs, '__scheduler_tick__');\n}\nfunction hasApplyArgsData(applyArgs, key) {\n  if (!Array.isArray(applyArgs)) {\n    return false;\n  }\n  if (applyArgs.length !== 1) {\n    return false;\n  }\n  return applyArgs[0]?.data?.[key] === true;\n}\n\nclass ErrorHandler {\n  _console = console;\n  handleError(error) {\n    this._console.error('ERROR', error);\n  }\n}\nconst INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {\n  factory: () => {\n    const zone = inject(NgZone);\n    const injector = inject(EnvironmentInjector);\n    let userErrorHandler;\n    return e => {\n      zone.runOutsideAngular(() => {\n        if (injector.destroyed && !userErrorHandler) {\n          setTimeout(() => {\n            throw e;\n          });\n        } else {\n          userErrorHandler ??= injector.get(ErrorHandler);\n          userErrorHandler.handleError(e);\n        }\n      });\n    };\n  }\n});\nconst errorHandlerEnvironmentInitializer = {\n  provide: ENVIRONMENT_INITIALIZER,\n  useValue: () => {\n    const handler = inject(ErrorHandler, {\n      optional: true\n    });\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && handler === null) {\n      throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');\n    }\n  },\n  multi: true\n};\nconst globalErrorListeners = new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'GlobalErrorListeners' : '', {\n  factory: () => {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return;\n    }\n    const window = inject(DOCUMENT).defaultView;\n    if (!window) {\n      return;\n    }\n    const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n    const rejectionListener = e => {\n      errorHandler(e.reason);\n      e.preventDefault();\n    };\n    const errorListener = e => {\n      if (e.error) {\n        errorHandler(e.error);\n      } else {\n        errorHandler(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}` : e.message, {\n          cause: e\n        }));\n      }\n      e.preventDefault();\n    };\n    const setupEventListeners = () => {\n      window.addEventListener('unhandledrejection', rejectionListener);\n      window.addEventListener('error', errorListener);\n    };\n    if (typeof Zone !== 'undefined') {\n      Zone.root.run(setupEventListeners);\n    } else {\n      setupEventListeners();\n    }\n    inject(DestroyRef).onDestroy(() => {\n      window.removeEventListener('error', errorListener);\n      window.removeEventListener('unhandledrejection', rejectionListener);\n    });\n  }\n});\nfunction provideBrowserGlobalErrorListeners() {\n  return makeEnvironmentProviders([provideEnvironmentInitializer(() => void inject(globalErrorListeners))]);\n}\n\nfunction ɵunwrapWritableSignal(value) {\n  return null;\n}\nfunction signal(initialValue, options) {\n  const [get, set, update] = createSignal(initialValue, options?.equal);\n  const signalFn = get;\n  const node = signalFn[SIGNAL];\n  signalFn.set = set;\n  signalFn.update = update;\n  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);\n  if (ngDevMode) {\n    signalFn.toString = () => `[Signal: ${signalFn()}]`;\n    node.debugName = options?.debugName;\n  }\n  return signalFn;\n}\nfunction signalAsReadonlyFn() {\n  const node = this[SIGNAL];\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    readonlyFn[SIGNAL] = node;\n    node.readonlyFn = readonlyFn;\n  }\n  return node.readonlyFn;\n}\n\nfunction assertNotInReactiveContext(debugFn, extraContext) {\n  if (getActiveConsumer() !== null) {\n    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);\n  }\n}\n\nclass ViewContext {\n  view;\n  node;\n  constructor(view, node) {\n    this.view = view;\n    this.node = node;\n  }\n  static __NG_ELEMENT_ID__ = injectViewContext;\n}\nfunction injectViewContext() {\n  return new ViewContext(getLView(), getCurrentTNode());\n}\n\nclass ChangeDetectionScheduler {}\nconst ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', {\n  factory: () => true\n});\nconst PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', {\n  factory: () => false\n});\nconst SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');\n\nclass PendingTasks {\n  internalPendingTasks = inject(PendingTasksInternal);\n  scheduler = inject(ChangeDetectionScheduler);\n  errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n  add() {\n    const taskId = this.internalPendingTasks.add();\n    return () => {\n      if (!this.internalPendingTasks.has(taskId)) {\n        return;\n      }\n      this.scheduler.notify(11);\n      this.internalPendingTasks.remove(taskId);\n    };\n  }\n  run(fn) {\n    const removeTask = this.add();\n    fn().catch(this.errorHandler).finally(removeTask);\n  }\n  static ɵprov =\n  /* @__PURE__ */\n  ɵɵdefineInjectable({\n    token: PendingTasks,\n    providedIn: 'root',\n    factory: () => new PendingTasks()\n  });\n}\n\nclass EffectScheduler {\n  static ɵprov =\n  /* @__PURE__ */\n  ɵɵdefineInjectable({\n    token: EffectScheduler,\n    providedIn: 'root',\n    factory: () => new ZoneAwareEffectScheduler()\n  });\n}\nclass ZoneAwareEffectScheduler {\n  dirtyEffectCount = 0;\n  queues = new Map();\n  add(handle) {\n    this.enqueue(handle);\n    this.schedule(handle);\n  }\n  schedule(handle) {\n    if (!handle.dirty) {\n      return;\n    }\n    this.dirtyEffectCount++;\n  }\n  remove(handle) {\n    const zone = handle.zone;\n    const queue = this.queues.get(zone);\n    if (!queue.has(handle)) {\n      return;\n    }\n    queue.delete(handle);\n    if (handle.dirty) {\n      this.dirtyEffectCount--;\n    }\n  }\n  enqueue(handle) {\n    const zone = handle.zone;\n    if (!this.queues.has(zone)) {\n      this.queues.set(zone, new Set());\n    }\n    const queue = this.queues.get(zone);\n    if (queue.has(handle)) {\n      return;\n    }\n    queue.add(handle);\n  }\n  flush() {\n    while (this.dirtyEffectCount > 0) {\n      let ranOneEffect = false;\n      for (const [zone, queue] of this.queues) {\n        if (zone === null) {\n          ranOneEffect ||= this.flushQueue(queue);\n        } else {\n          ranOneEffect ||= zone.run(() => this.flushQueue(queue));\n        }\n      }\n      if (!ranOneEffect) {\n        this.dirtyEffectCount = 0;\n      }\n    }\n  }\n  flushQueue(queue) {\n    let ranOneEffect = false;\n    for (const handle of queue) {\n      if (!handle.dirty) {\n        continue;\n      }\n      this.dirtyEffectCount--;\n      ranOneEffect = true;\n      handle.run();\n    }\n    return ranOneEffect;\n  }\n}\n\nclass EffectRefImpl {\n  [SIGNAL];\n  constructor(node) {\n    this[SIGNAL] = node;\n  }\n  destroy() {\n    this[SIGNAL].destroy();\n  }\n}\nfunction effect(effectFn, options) {\n  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');\n  if (ngDevMode && !options?.injector) {\n    assertInInjectionContext(effect);\n  }\n  if (ngDevMode && options?.allowSignalWrites !== undefined) {\n    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  let node;\n  const viewContext = injector.get(ViewContext, null, {\n    optional: true\n  });\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null) {\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      destroyRef = null;\n    }\n  } else {\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n  if (destroyRef !== null) {\n    node.onDestroyFns = [destroyRef.onDestroy(() => node.destroy())];\n  }\n  const effectRef = new EffectRefImpl(node);\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? '';\n    const prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n  return effectRef;\n}\nconst EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...BASE_EFFECT_NODE,\n  cleanupFns: undefined,\n  zone: null,\n  onDestroyFns: null,\n  run() {\n    if (ngDevMode && isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    const prevRefreshingViews = setIsRefreshingViews(false);\n    try {\n      runEffect(this);\n    } finally {\n      setIsRefreshingViews(prevRefreshingViews);\n    }\n  },\n  cleanup() {\n    if (!this.cleanupFns?.length) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer$1(null);\n    try {\n      while (this.cleanupFns.length) {\n        this.cleanupFns.pop()();\n      }\n    } finally {\n      this.cleanupFns = [];\n      setActiveConsumer$1(prevConsumer);\n    }\n  }\n}))();\nconst ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.scheduler.schedule(this);\n    this.notifier.notify(12);\n  },\n  destroy() {\n    consumerDestroy(this);\n    if (this.onDestroyFns !== null) {\n      for (const fn of this.onDestroyFns) {\n        fn();\n      }\n    }\n    this.cleanup();\n    this.scheduler.remove(this);\n  }\n}))();\nconst VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...EFFECT_NODE,\n  consumerMarkedDirty() {\n    this.view[FLAGS] |= 8192;\n    markAncestorsForTraversal(this.view);\n    this.notifier.notify(13);\n  },\n  destroy() {\n    consumerDestroy(this);\n    if (this.onDestroyFns !== null) {\n      for (const fn of this.onDestroyFns) {\n        fn();\n      }\n    }\n    this.cleanup();\n    this.view[EFFECTS]?.delete(this);\n  }\n}))();\nfunction createViewEffect(view, notifier, fn) {\n  const node = Object.create(VIEW_EFFECT_NODE);\n  node.view = view;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = createEffectFn(node, fn);\n  view[EFFECTS] ??= new Set();\n  view[EFFECTS].add(node);\n  node.consumerMarkedDirty(node);\n  return node;\n}\nfunction createRootEffect(fn, scheduler, notifier) {\n  const node = Object.create(ROOT_EFFECT_NODE);\n  node.fn = createEffectFn(node, fn);\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\n  node.scheduler.add(node);\n  node.notifier.notify(12);\n  return node;\n}\nfunction createEffectFn(node, fn) {\n  return () => {\n    fn(cleanupFn => (node.cleanupFns ??= []).push(cleanupFn));\n  };\n}\n\nfunction untracked(nonReactiveReadsFn) {\n  return untracked$1(nonReactiveReadsFn);\n}\n\nexport { AFTER_RENDER_SEQUENCES_TO_ADD, ANIMATIONS, CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTAINER_HEADER_OFFSET, CONTEXT, ChangeDetectionScheduler, CheckNoChangesMode, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DECLARATION_VIEW, DEHYDRATED_VIEWS, DOCUMENT, DestroyRef, EFFECTS, EFFECTS_TO_SCHEDULE, EMBEDDED_VIEW_INJECTOR, EMPTY_ARRAY, EMPTY_OBJ, ENVIRONMENT, ENVIRONMENT_INITIALIZER, EffectRefImpl, EffectScheduler, EnvironmentInjector, ErrorHandler, EventEmitter, FLAGS, HEADER_OFFSET, HOST, HYDRATION, ID, INJECTOR$1 as INJECTOR, INJECTOR as INJECTOR$1, INJECTOR_DEF_TYPES, INJECTOR_SCOPE, INTERNAL_APPLICATION_ERROR_HANDLER, InjectionToken, Injector, MATH_ML_NAMESPACE, MOVED_VIEWS, NATIVE, NEXT, NG_COMP_DEF, NG_DIR_DEF, NG_ELEMENT_ID, NG_FACTORY_DEF, NG_INJ_DEF, NG_MOD_DEF, NG_PIPE_DEF, NG_PROV_DEF, NgZone, NoopNgZone, NullInjector, ON_DESTROY_HOOKS, PARENT, PREORDER_HOOK_FLAGS, PROVIDED_ZONELESS, PendingTasks, PendingTasksInternal, QUERIES, R3Injector, REACTIVE_TEMPLATE_CONSUMER, RENDERER, RuntimeError, SCHEDULE_IN_ROOT_ZONE, SCHEDULE_IN_ROOT_ZONE_DEFAULT, SVG_NAMESPACE, TVIEW, T_HOST, VERSION, VIEW_REFS, Version, ViewContext, XSS_SECURITY_URL, ZONELESS_ENABLED, _global, addToArray, angularZoneInstanceIdProperty, arrayEquals, arrayInsert2, arraySplice, assertComponentType, assertDefined, assertDirectiveDef, assertDomNode, assertElement, assertEqual, assertFirstCreatePass, assertFirstUpdatePass, assertFunction, assertGreaterThan, assertGreaterThanOrEqual, assertHasParent, assertInInjectionContext, assertIndexInDeclRange, assertIndexInExpandoRange, assertIndexInRange, assertInjectImplementationNotEqual, assertLContainer, assertLView, assertLessThan, assertNgModuleType, assertNodeInjector, assertNotDefined, assertNotEqual, assertNotInReactiveContext, assertNotReactive, assertNotSame, assertNumber, assertNumberInRange, assertOneOf, assertParentView, assertProjectionSlots, assertSame, assertString, assertTIcu, assertTNode, assertTNodeCreationIndex, assertTNodeForLView, assertTNodeForTView, attachInjectFlag, concatStringsWithSpace, convertToBitFlags, createInjector, createInjectorWithoutInjectorInstances, cyclicDependencyError, cyclicDependencyErrorWithDetails, debugStringifyTypeForError, decreaseElementDepthCount, deepForEach, effect, emitAfterRenderEffectPhaseCreatedEvent, emitInjectEvent, emitInjectorToCreateInstanceEvent, emitInstanceCreatedByInjectorEvent, emitProviderConfiguredEvent, enterDI, enterSkipHydrationBlock, enterView, errorHandlerEnvironmentInitializer, fillProperties, flatten, formatRuntimeError, forwardRef, getBindingIndex, getBindingRoot, getBindingsEnabled, getClosureSafeProperty, getComponentDef, getComponentLViewByIndex, getConstant, getContextLView, getCurrentDirectiveDef, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentQueryIndex, getCurrentTNode, getCurrentTNodePlaceholderOk, getDirectiveDef, getDirectiveDefOrThrow, getElementDepthCount, getFactoryDef, getInjectableDef, getInjectorDef, getLView, getLViewParent, getNamespace, getNativeByIndex, getNativeByTNode, getNativeByTNodeOrNull, getNgModuleDef, getNgModuleDefOrThrow, getNullInjector, getOrCreateLViewCleanup, getOrCreateTViewCleanup, getPipeDef, getSelectedIndex, getSelectedTNode, getTNode, getTView, hasI18n, importProvidersFrom, increaseElementDepthCount, incrementBindingIndex, initNgDevMode, inject, injectRootLimpMode, internalImportProvidersFrom, isClassProvider, isComponentDef, isComponentHost, isContentQueryHost, isCreationMode, isCurrentTNodeParent, isDestroyed, isDirectiveHost, isEnvironmentProviders, isExhaustiveCheckNoChanges, isForwardRef, isInCheckNoChangesMode, isInI18nBlock, isInInjectionContext, isInSkipHydrationBlock, isInjectable, isLContainer, isLView, isProjectionTNode, isRefreshingViews, isRootView, isSkipHydrationRootTNode, isStandalone, isTypeProvider, keyValueArrayGet, keyValueArrayIndexOf, keyValueArraySet, lastNodeWasCreated, leaveDI, leaveSkipHydrationBlock, leaveView, load, makeEnvironmentProviders, markAncestorsForTraversal, markViewForRefresh, newArray, nextBindingIndex, nextContextImpl, provideBrowserGlobalErrorListeners, provideEnvironmentInitializer, providerToFactory, removeFromArray, removeLViewOnDestroy, renderStringify, requiresRefreshOrTraversal, resetPreOrderHookFlags, resolveForwardRef, runInInjectionContext, runInInjectorProfilerContext, scheduleCallbackWithMicrotask, scheduleCallbackWithRafRace, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setCurrentTNodeAsNotParent, setInI18nBlock, setInjectImplementation, setInjectorProfiler, setInjectorProfilerContext, setIsInCheckNoChangesMode, setIsRefreshingViews, setSelectedIndex, signal, signalAsReadonlyFn, store, storeCleanupWithContext, storeLViewOnDestroy, stringify, stringifyForError, throwError, throwProviderNotFoundError, truncateMiddle, untracked, unwrapLView, unwrapRNode, updateAncestorTraversalFlagsOnAttach, viewAttachedToChangeDetector, viewAttachedToContainer, walkProviderTree, walkUpViews, wasLastNodeCreated, ɵunwrapWritableSignal, ɵɵdefineInjectable, ɵɵdefineInjector, ɵɵdisableBindings, ɵɵenableBindings, ɵɵinject, ɵɵinvalidFactoryDep, ɵɵnamespaceHTML, ɵɵnamespaceMathML, ɵɵnamespaceSVG, ɵɵresetView, ɵɵrestoreView };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}